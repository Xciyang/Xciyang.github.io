{"pages":[{"title":"关于","text":"2019.12.17写了一个HTML5 CANVAS + JS交互式动画BallMouse，可用于Hexo博客。 2019.12.9苟在机房更换了博客主题现在是Icarus，打算从一个简洁的主题开始自定义。 2019.10.22退役AFO。 2019.08.22写了一个应用于洛谷的油猴插件LuoguQuickSearcher，并写了一篇开发过程的博客。 2019.08.15更换了博客主题，现在使用的是Nexmoe，原来使用的是Matery。 关于我的更多内容：重新开始","link":"/about/index.html"},{"title":"小说？","text":"名字没想好 索引第一节、深夜短信","link":"/book/index.html"},{"title":"搜索","text":"","link":"/search/index.html"},{"title":"友情链接","text":"My Friends 互加友链下方评论哦！","link":"/friends/index.html"}],"posts":[{"title":"比赛 - AtCoder Beginner Contest 142","text":"【AtCoder Beginner Contest 142】比赛链接: https://atcoder.jp/contests/abc142 前言这次比赛略水，真是上分的好比赛。作为仅有300+rating的我直接安排，AK比赛后直接上到900+。 比赛中有几个题对我还是比较有意义的。 题解A题意翻译： 给出一个数$N$，从$1~N$中随机抽取，求抽到奇数的概率。 这题还挺简单，再看数据范围$1 &lt;= N &lt;= 100$，太水了！ B题意翻译： 第一行给出一个数$N$代表一个数列的长度，再给出$K$。第二行给出数列各项的值。求数列中大于等于$K$的个数。 数据范围$1 &lt;= N &lt;= 10^5$，也很水，入门难度。 C题意翻译： 一个教室中有$N$名同学，给出每个同学到达教室时教室中的人$A_i$（包括自己），求出到达顺序。 数据范围$1 &lt;= N &lt;= 10^5$，正常范围。 直接上排序，按$A_i$从小到大排序，最后依次输出编号。 D这题看了好长时间才看懂题目。 题意翻译： 给出两个数$A$、$B$，求出两个数的共同约数集合的一个子集。这个子集满足各元素两两直接都互质，求出子集最多包含多少元素。 数据范围$1 &lt;= A,B &lt;= 10^{12}$。 看起来好像有点麻烦，但实际上我们先求出$C=gcd(A, B)$，那么$C$的约数就是两个数的共同约数。然后再分解质因数即可，题目转换为求一个较大的数的质因数个数。 核心代码： 123long long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a;} 12345678long long ans= 1;for(long long i= 2; i * i &lt;= m; i++) { if(m % i == 0) { ++ans; while(m % i == 0) m/= i; }}if(m &gt; 1) ++ans; E题目到这已经不再那么水了。 题意翻译： 给出一个数$N$代表多少上锁的盒子，再给出一个数$M$代表有多少钥匙。每个钥匙需要花$A_i$来购买，可以打开$B_i$个盒子，分别为$C_{ij}$，一个钥匙可以多次使用。问打开所有盒子的最小花费，若无解输出-1。 数据范围$1 &lt;= N &lt;= 12$、$1 &lt;= M &lt;= 10^3$、$1 &lt;= A_i &lt;= 10^5$ 一开始没看数据范围我以为是舞蹈链，差点自闭了。然后再看数据范围，$N$比较小，于是想到状压DP。 设置一个数组$F[1 &lt;&lt; N]$表示打开某些盒子的最小花费。 先枚举$M$个钥匙钥匙，对将钥匙能打开的盒子二进制压缩到数$X$，然后取最小值。 核心代码： 12345int getx(int x) { int res= 0; for(int i= 1; i &lt;= b[x]; i++) res+= (1 &lt;&lt; (c[x][i] - 1)); return res;} 然后再写转移方程，由于我比较傻，所以一开始写了$F[i | j] = min(F[i] + F[j])$，结果反而枚举的是$x = i | j$。看起来复杂度$2^{3N}$，然后确实TLE了。 然后我想把方程改为$F[i] = min(F[i], f[j] + f[i ^ j])$，现在想想好像枚举i,j就可以了，那样复杂度$2^{2N}$好像能过，可惜我比赛时没想这种方法。 我在比赛时用了更麻烦的方法，因为我想起了之前一道题，在初始化时枚举二进制所有子集全部更新。这样预处理复杂度最大$M * 2^{N}$能过，然后再DP。我就来Blog上擅用搜索引擎，搜到了AT2657 - Mole and Abandoned Mine。 然后非常套路的预处理出每个数二进制下1的个数。 核心代码： 12345int getg(int x) { int res= 0; while(x) ++res, x-= (x &amp; -x); return res;} 12345678910111213141516int maxx= (1 &lt;&lt; n);for(int i= 0; i &lt; maxx; i++) w[i]= getg(i);memset(f, 0x3f, sizeof(f));for(int i= 1, j; i &lt;= m; i++) { j= getx(i); for(int k= j; k; k= (k - 1) &amp; j) f[k]= min(f[k], a[i]);}for(int i= 1; i &lt;= n; i++) { for(int j= 0; j &lt; maxx; j++) { if(w[j] != i) continue; for(int k= 0; k &lt; maxx; k++) { if(j == k || w[k] &gt;= i || (k &amp; (~j))) continue; f[j]= min(f[j], f[k] + f[k ^ j]); } }} F终于到最后一题，比较激动。题目还挺复杂的。 题意翻译： 给出一个图G，有$N$个点，$M$条单向边，无自环和重边。求出一个子图包含$N’$个点，$M’$为这些点构成的边，满足所有点的入度和出度都为1。如果有多个子图，输出任意一个。输出$N’$和包含的点。无解输出-1。 数据范围$1 &lt;= N &lt;= 1000$、$1 &lt;= M &lt;= 2000$ 感觉有点难，但毕竟SpecialJudge可以一试，可能会有简单做法。 先手膜一些图，发现暴力DFS可做。虽然是类似ACM的赛制，但剩余时间不多了，先打个试试吧。 再膜一下第三组数据，发现只要有环就一定有解。 因为入度出度为一，可以把这个图称为单环。我们从每个点DFS，让途中经过的点的所有能到达的点入度+1。这样DFS时，如果一个点入度已经大于1，那么从起始点开始一定不能与当前状态构成单环。所以我们每次DFS一个能到达的入度为1的点。点。再记录我们已经走过的点，如果又一次到达某点，那么一定形成了单环。如果某次更新时，途中走过的点的入度&gt;1了，那么这个点也不能与当前状态构成单环。 解释不清楚，核心代码： 1234567891011121314151617181920212223int n, m, tmpx, tmpy, r[1005], st[1005], ans[1005];vector&lt; int &gt; edg[1005];int dfs(int nown) { if(st[nown]) return 1; st[nown]= 1; for(int i= 0; i &lt; edg[nown].size(); i++) { ++r[edg[nown][i]]; if(r[edg[nown][i]] &gt; 1 &amp;&amp; st[edg[nown][i]]) { for(int j= 0; j &lt;= i; j++) --r[edg[nown][j]]; st[nown]= 0; return 0; } } for(int i= 0; i &lt; edg[nown].size(); i++) { if(r[edg[nown][i]] == 1 &amp;&amp; dfs(edg[nown][i])) { ans[++ans[0]]= nown; return 1; } } for(int i= 0; i &lt; edg[nown].size(); i++) --r[edg[nown][i]]; st[nown]= 0; return 0;} 我一开始的做法是，枚举每个点为起始点跑一次DFS，直到找出答案，然后就TLE了几个点，但是AC了大部分就还能救。 既然DFS都是乱搞，那就再加一个随机化。本题时限2s，那么不到1.8s我们就继续DFS。 然后复杂度我也不太会证明，因为DFS复杂度也非常玄学。大概是O(能过)。最后输出答案我还sort了一遍，因为样例是排序好的。 核心代码： 123srand(time(0));while(clock() &lt; CLOCKS_PER_SEC * 1.8) if(dfs(rand() % n + 1)) break; 后记仍犯了很多错误，A题一开始竟把奇数看成质数，D题枚举因数没开long long。","link":"/2019-09/29-atbeginner142/"},{"title":"CSP-S 2019 · AFO游记","text":"打算写一篇游记，以便以后能够回想起这段美好的颓废时光。 然而一直没有时间写游记，因为最近来机房的次数变少了。其实几周前就已经写完在草稿纸上了，而且一部分已经打到家里的笔记本上了，然后忘了保存到QQ里，因此打算再重写一篇。 内容较多，语言冗长，请见谅。 Day -1上午一题没写，虽说有场模拟赛但并不想打。在Github和知乎上来回切换颓了一上午加一中午，中午还刷了会（低俗）微博？ 下午Loli召开神圣的经验传授大会，大佬们纷纷讲话，当然好多大佬都回家休息了。轮到我时就只能说说自己的骗分和爆零经历了，然而有些想说的微不足道的注意事项上台全忘了。开完会继续颓废，然后找R一起看了一道Tarjan。 从R的一个暴力的基础上优化成可过，但是要再写多个小算法。R准备写的时候看到了我的此题的记录，好像Tarjan后只需几行（我很久前AC时大概率是抄的题解，已经全忘了），稍微一下觉得有锅，出了几组数据把暴力都hack了。又手推了几组数据想出了正确思路，然后样例过了，提交全WA。再看代码，多读入一个数字M，竟然过了样例。删去后，样例反而过不去了，一顿查错调试改了好几处小错误，终于AC了。 AC完并没有很激动，反而我们都很慌。这种错误在NOIP中年年都有，从AC到零蛋，从省队到送退役。又和R讨论发现明天此时已经快到日照了，都开始慌了。之后全员打扫机房，做好退役的准备。 晚上请假回家颓废，收拾行李。 Day 0早上想打打板子，发现AK司在打一场名为模板题大赛的洛谷个人赛。我也跟着报名了，这大概是退役前最后一场模拟赛。看题后，发现并不是模板题，T1打了一个DFS，然后被毒瘤输出（全文比较，不忽略空格及换行）卡了，很久才通过。再看排行榜，Rank1仅通过3题，总共5题，AK司通过2题。 又看了T2，也不是模板题，而且并没有什么思路，只知道是个DP，但还需要一些性质或者其他算法结合一下。此时已经中午，先想了个三分处理就去吃饭了，回来发现还是不会。打算再意识写写的时候已经12点，该出发去校门口集合了。 然后就很正常的坐上了车，开始颓手机。 到达考点校区已经五点多了吧，先去了宿舍，和几个学弟（学长），ArachnidaKing和Juan_Feng在一个宿舍。然后去吃饭，逛超市，准备试机。 中途还与AK司讨论了上午的模拟赛，T2思路复杂，而且显然过多难以证明因此放弃，并认为CSP不会考这种智力题。 因为SDSC来过的原因，所以对校区比较熟悉，几行人就直接去了考场大楼（实验实训中心）。在楼下面LED滚动屏上还看到了祝CPS考生考试顺利！，纷纷拍照留念。这次对没来过的人挺友好的，楼内都有路标，这样绕来绕去也不会晕了。 排队进入考场，找到座号，一切顺利。系统Win7，键盘可用，调试可用。然后顺次打了快读、SPFA、LCA，打的过程中想到明天就在这看题了，就觉得又稳又慌。等到打一半模拟退火时试机结束了。我本想跑回宿舍，然而中途被带队老师叫住跟着大部队!。 晚上先和学弟颓了会王者，用着极慢的网速还拿了MVP，感觉RP++了。再打开之前准备的NOIP算法索引，最后再看看代码。大概十一点半多久睡着了吧。 Day 1进考场前都非常正常，并没有RP—的事情发生。进了考场，先建好文件夹，准备输入压缩包密码。密码是认真思考和2019组合起来，等待解压，打开PDF。 先大概记了一下时限和内存，还有编译指令。顺序开题，T1题面较复杂，然而看到前一半，后一半的时候就觉得是个log做法，递归或者二分。再看到数据范围$N &lt; 64$时发现比较稳，直接开始写代码。虽然只过了第一个样例，但是立刻发现填0后紧接着要去反，然后样例都过了。又看到数据范围$K &lt; 2^{64} - 1$，再想到ULL最大就是这个数字，我改成ULL。又发现代码中让K自加了，因此特判了$2^{64} - 1$的点。又开始美化代码，将$(1 &lt;&lt; i) / 2$美化成$(1 &lt;&lt; (i - 1))$，然而比赛后才发现这竟然是个坑点，碰巧没踩中。此时大概半个小时，写了个暴力vector和string对拍一下都过了，就觉得100稳了。 再看T2，一开始觉得不可做。当看到从1出发时，才觉得可做。立刻想到一个$O(N)$的正确性未知的处理单个串做法，发现和普通的括号匹配只差了个计数。只需要维护两个计数器，遇到(清零连续计数器并放入栈内，遇到)时将计数器赋值为栈顶+1并且弹出，在维护一个答案计数器，然后按题意即可。再考虑回溯，用手工栈和系统栈结合一下就过了样例一。然而样例二没过，发现是少了一条语句，补完过了样例二。又手动开栈过了样例三，感觉很稳就没有对拍。 此时已经2h，觉得自己200比较稳，就休息了一下。看完T3题面，并没有读懂，好像读颠倒了。然而做起来只是逻辑关系更混乱了，并不影响答案。先写了个10分全排列，然后猜了个性质。想了好久，打个了个LCA+BFS，连样例二都没过，又调试微调也没什么用。全部删掉打了个随机化发现和暴力没啥区别。此时就剩整理文件、检查考号、文件名的时间了。 出了考场，遇到了asuldb和R，交流发现我T1并没有踩坑，然后T3确实很难。吃完饭回宿舍，先是和学弟颓了局王者，然而网速非常慢，全场被队友带飞。又玩了4399小游戏，玩了小学时爱玩的造梦西游3和一些小游戏。四点多的时候想起了机器人赛跑，六七个人一起玩，都非常愉悦。然而中途Loli敲门，我去开门，幸好大家反应快，只奶了几句就走了。 晚上看知乎，上午T3的出题人匿名发题解。T2被吐槽样例恶臭，而且非常水，引起了一定恐慌。再复习了些代码，十一点半熄灯，很快就睡着了。 Day1期望得分：100+100(?)+10=210 Day 2起床，吃饭都非常正常。与ctz、ArachnidaKing走在去考场的路上，中途偶遇Loli，他拍了拍ArachnidaKing的肩膀：别着急，慢慢来。进了考场，肚子感到不适，此时离开始还有二十多分钟，又申请出了考场。回来时只剩下十几分钟了，依然是考前准备，听到密码是抓紧时间和几个字符组合。 一样的流程，顺序开题。T1看了觉得是DP，但是数据范围又很复杂，差点看晕了。计算了复杂度为$O(M^N)$的DFS，包含多个范围，能拿到32分的好成绩，那就先打上了。再仔细思考，感觉正解肯定效率也不太高。又感觉是舞蹈链，但是差别有点大，而且CSP应该不会考。 只好去看T2，题目形式化的东西看起来不可做。但是发现时自行设置划分数，就觉得没那么难。先想到一个$O(N)$预处理和统计答案时就开始写，倒序的思想，然而过不去样例二。出了几组数据hack后，发现可以用单调栈。其实是自己傻了，把栈想成先进先出了，连样例一都过不去。写了个dfs对拍，发现倒序是正确的，只是预处理有问题。然后单调栈改成单调队列依旧没有调出来，只能改成$O(N^2)$能拿64分。 此时已经2h多，计算一下两天总分刚过300，有点慌张。抓紧看了T3，看到题目名称是树的重心就知道必不是树的重心。题目描述比较清楚，暴力做法大概就是麻烦的DFS。又看数据范围，$O(N^2)$可拿40分，一条链的再多拿15分，二叉树并不熟悉，先不考虑。然后急匆匆的打完部分分，样例过了，再手推二叉树，发现连二叉树具体是啥都不知道，只能放弃。 然而比赛只剩半个多小时，回去看T1。仔细想了想，觉得自己想不出正解，想出了也写不完了，仔细思考数据范围，发现有个$O(N^M)$的DP，能多32分。但是这种DP我并不熟悉，似乎记忆化并不可行（？），大概是想简单了。写完后就离考试结束只剩十分钟了，然而样例并没有过，因为是3维数组所以不易调试（现在想想应该先打2维的）只能放弃，恢复成原来的代码。最后再检查程序、文件夹然后就交卷了。 出考场交流好像很多人都挂的很厉害，似乎我分数还行，不会被Loli强制退役？问了潮发现今天T1确实可以多维数组DP，还是自己平常没怎么打，一到正式比赛把细节都忘了。 下午觉得自己今天T1没有取摸，可能只有24分了。晚上回家又听说学弟D1T2挂了，然后我也默写提交试一试。提交后只有55分，发现是一条语句没加，导致只能处理一条链的情况。细思极恐，也不知道是默写忘了还是考场上就没加，毕竟样例又那么水。 又看了SDOI群里，听说390左右能清北冬令营？怕是自己真的就差了今天T1没打完的部分分。 Day2期望得分：32+64+55=151 Day 5+拿下源程序，都没写挂。在Luogu和Loli的数据上测了，发现D2T2还多了24分，怕是数据水（确实是）。然后看到csp.ac的数据是361，才知道Luogu是真的数据水。。。再看牛客，大家都莫名其妙挂了分，只能等着CCF发成绩了。 Day Inf官方成绩100+100+10+32+64+55=361，和考场上估计的一模一样。虽然这个分数也不算差，但是还是有很多遗憾。 和THUWC、PKUWC无缘了，只能盼望着CCF给我去NOIWC见见世面的机会了。","link":"/2019-12/09-csps2019afo/"},{"title":"Daily Literary - 文艺日常","text":"半年没更新了啊！ 最近更新: 2020.01.04 图片来源于网络，如有侵权请联系我。 日常收集文艺语句，来源于知乎、网页、原创。 喜欢上一个人很容易，爱上一个人很难，但是忘掉一个人是最难的。 喜欢一样东西就不要问别人好不好看。这个世界上永远没有感同身受，真正能治愈自己的，只有你自己。 太敏感的人会体谅到他人的痛苦，自然就无法轻易做到坦率。所谓的坦率，其实就是暴力。 世上的事情都经不起推敲，一推敲，哪一件都藏着委屈。 我慢慢明白了我为什么不快乐，因为我总是期待一个结果。 人生所有的希望，都是在绝望中得到了领悟。 拥有的总是不安，没得到的都喜欢。你和余生正相反，而我曾一度，混为一谈。 有些笑容背后是紧咬牙关的灵魂。 你可以拥有一切，但不能同时。 关于本篇持续更新，作者也不知道怎么回事就开了这个专栏。","link":"/2019-08/21-literatureandart/"},{"title":"NOIP2009 - Hankson 的趣味题","text":"【LuoguP1072】【NOIP2009】Hankson 的趣味题题目链接: https://www.luogu.org/problemnew/show/P1072 引言半个月没更新博客了, 一直忙于做题练习和学文化课, 不然快被劝退了 最近学习一本通提高篇, 复习下之前学的GCD等数论知识 分析先从题目描述说起, 给出了a0, a1, b0, b1四个数 求 $ gcd(x, a0) = a1 $ 且 $ lcm(x, b0) = b1 $ 中 x 的方案数 那么首先我们都知道两个很基础的东西 gcd(a, b) = gcd(b, a\\mod b)lcm(a, b) = a × b / gcd(a, b)然后就可以来做这道题了 因为 lcm(x, b0) = x × b0 / gcd(x, b0) = b1所以 x = \\frac{b1}{b0} × gcd(x, b0)我们设一个数 $ y = gcd(x, b0) $ 那么一定 $ 1 ≤ y ≤ \\sqrt{b0} $ 所以我们只要枚举 y 的值, 然后代入算出 $ x = b1 / b0 × y $ 然后代入题目中的两个式子进行判断 还有一个简化 x × b0 / gcd(x, b0) == b1可简化为 b1 / b0 × y × b0 / gcd(x, b0) == b1即 gcd(x, b0) == y要判断 $ x = b1 / y $ 的情况, 也有可能是一个解 也不要忘了特判 $ y = \\sqrt{b0} $ 的情况 然后就完美解决了 代码没有开各种优化, 能过 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;using namespace std;int n, a0, a1, b0, b1, ans, tmpx, tmpq;int gcd(int a, int b) { if(b == 0) return a; return gcd(b, a % b);}int main() { cin &gt;&gt; n; while(n--) { cin &gt;&gt; a0 &gt;&gt; a1 &gt;&gt; b0 &gt;&gt; b1; ans= 0; for(int i= 1; i &lt; sqrt(b0); i++) { if(b0 % i == 0) { tmpx= b1 / b0 * i; if(gcd(tmpx, a0) == a1 &amp;&amp; gcd(tmpx, b0) == i) ++ans; tmpx= b1 / i; if(gcd(tmpx, a0) == a1 &amp;&amp; gcd(tmpx, b0) == b0 / i) ++ans; } } tmpq= sqrt(b0); if(tmpq * tmpq == b0) { tmpx= b1 / b0 * tmpq; if(gcd(tmpx, a0) == a1 &amp;&amp; gcd(tmpx, b0) == tmpq) ++ans; } cout &lt;&lt; ans &lt;&lt; endl; } return 0;}","link":"/2019-03/03-luogu1072/"},{"title":"NOIP2001 - 统计单词个数","text":"【NOIP2001】【LuoguP1026】统计单词个数题目链接: https://www.luogu.org/problem/P1026 前言这题要不是有DP标签我还真想不出这种思路。 分析首先题目描述有点不清楚，结合样例更加好理解。差不多为，字符串长度不超过200，单词种类不超过6个，将字符串分40段求最大单词匹配总数。 然后给出了一个性质，一个字符自能被当做一次首字符，所以就可以用线性做法。 我们先预处理，求出每个单词在字符串中的所有匹配位置。那么如果几个单词重叠了该怎么办呢？ 很容易想到，字符串中某字符被当做首字母时，匹配最短的单词最优。因此我们可以求出字符串中每一个字符当首字母时的最短长度。 如果使用string可以使用find函数，但输入时较为麻烦。所以我用char数组存储，并使用strstr函数。 接下来考虑DP方程。（因为有DP标签，才会拼凑DP思路，考场上还真不一定想出DP解法） 非常典型的设一个$F[N][K]$，表示处理到第N个字符，分割为K部分。 先上经典转移方程进行修改。 F[i][j] = max(F[i - 1][j], f[i - 1][j - 1])但你会发现这样没地方加入预处理出的最短长度。因为后面转移时，单词有可能从中间被切开，这样求出答案就是错了。 然后就写了个鬼畜的方程，设$W_i$为字符串中第i字符当首字母时最短长度（如果不能匹配则无限大）。 所以$i$会影响到$i + W_i$后的答案，使他们答案+1，取个max。 然后我们以j为第一关键字，i为第二关键字枚举即可。因为我们分隔字符只会让答案变小，所以将方程改为。 F[i][j] = max(F[i][j], f[i - 1][j - 1])代码1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;int p, k, s, w[405], len[7], a[405], f[205][45];char tmps[405], zd[7][205];int main() { cin &gt;&gt; p &gt;&gt; k; for(int i= 0; i &lt; p; i++) cin &gt;&gt; (tmps + i * 20 + 1); p*= 20; memset(w, 0x3f, sizeof(w)); cin &gt;&gt; s; for(int i= 1; i &lt;= s; i++) { cin &gt;&gt; zd[i], len[i]= strlen(zd[i]); char *st= strstr(tmps + 1, zd[i]); while(st) { w[st - tmps]= min(w[st - tmps], len[i]); st= strstr(st + 1, zd[i]); } } for(int l= 1; l &lt;= k; l++) { for(int i= l; i &lt;= p; i++) { f[i][l]= max(f[i][l], f[i - 1][l - 1]); if(w[i] != 0x3f3f3f3f) { for(int j= max(i + w[i] - 1, i + 1); j &lt;= p; j++) f[j][l]= max(f[j][l], f[i][l]) + 1; if(w[i] == 1) ++f[i][l]; } } } cout &lt;&lt; f[p][k] &lt;&lt; endl; return 0;}","link":"/2019-09/25-luogu1026/"},{"title":"LuoguP1282 - 多米诺骨牌","text":"【LuoguP1041】多米诺骨牌题目链接: https://www.luogu.org/problem/P1282 前言最近重点做动态规划。今天自己成功推出了两三道题，然后开始水多年未更新的博客？ 不能颓废！ 分析首先看数据范围$(N &lt;= 1000, A_i/B_i &lt;= 6)$，那么搜索当然不可能，肯定是考虑动态规划。 还是回归搜索上，比较好分析。一个牌只有两种状态，旋转与不旋转。我们只需要先找到最小差，再考虑最小旋转次数。 再看数据范围，$O(6N^2)$不会超时。我们既要求最小差又要求最小最小旋转次数，又可知所有数的总和是确定的，不如就设个背包。 $F[N(1000)][SUM(6000)]$表示处理到第N个点，上方块的和为SUM时最小的旋转次数。 一开始除$F[0]$为0外都赋值为无穷大，然后转移$A_i$表示上方块,$B_i$表示下方块。 F[N][i] = min(F[N - 1][i - A_i], F[N - 1][i - B_i] + 1)然后由于比较闲（怕超空间，然而并不会？）。显然，只要记录N-1的状态，就开了滚动数组$F[2][SUM]$。 最后先找最小差，我们计算$X = \\lfloor\\frac{SUM}{2} \\rfloor$。 如果$SUM$为奇，那么上下差不可能为0，并且上方块和为$X$或$X + 1$时差都为1，因此再设置$Y = X + 1$。 如果$SUM$为偶，那么上方块和为$X$时上下差就为0，$Y = X$。 我们枚举一个数$i$从0开始，不断增大，表示一个范围（大概是这样）。 判断$F[N][X - i]$和$F[N][Y + i]$是否有值，若有则输出小的那个。 代码代码较丑，推荐自己写代码。 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;int n, a[1005], b[1005], c[1005], f[2][8000], sum;int main() { cin &gt;&gt; n; for(int i= 1; i &lt;= n; i++) cin &gt;&gt; a[i] &gt;&gt; b[i], c[i]= a[i] - b[i], sum+= a[i] + b[i]; memset(f, 0x3f, sizeof(f)); f[0][0]= 0; for(int i= 1; i &lt;= n; i++) { for(int j= 0; j &lt;= sum; j++) f[i &amp; 1][j]= 0x3f3f3f3f; for(int j= sum; j &gt;= a[i]; j--) f[i &amp; 1][j]= f[(i &amp; 1) ^ 1][j - a[i]]; for(int j= sum; j &gt;= b[i]; j--) f[i &amp; 1][j]= min(f[i &amp; 1][j], f[(i &amp; 1) ^ 1][j - b[i]] + 1); } int res= 0x3f3f3f3f, sum1= sum / 2, sum2= sum1 + sum % 2; for(int i= 0; i &lt; sum; i++) { if(sum1 + i &gt; n &amp;&amp; sum2 - i &lt; 1) break; res= min(f[n &amp; 1][sum1 + i], f[n &amp; 1][sum2 - i]); if(f[n &amp; 1][sum1 + i] != 0x3f3f3f3f || f[n &amp; 1][sum2 - i] != 0x3f3f3f3f) break; } cout &lt;&lt; res &lt;&lt; endl; return 0;} 后记我的代码必须开8000，如果开8000以下好像会RE。","link":"/2019-09/19-luogu1282/"},{"title":"NOIP2003 - 传染病控制","text":"【LuoguP1041】【NOIP2003】传染病控制题目链接: https://www.luogu.org/problemnew/show/P1041 前言这道题正解搜索, 然而可能有一些同学和我一样一开始觉得能用DP做的…推完递推式, 打完DP只有40, 然后也没有找出错误. 我这篇题解主要就来说一下这个DP的思路和错误. 如果你已经懂了DFS思路, 可以理解一下错误DP的思想, 如果看不出错误, 很可能是你对这个题的题意还不够清楚. 分析先建图, 是以1节点为根的一棵树. 我们开一个一维数组f, 下标代表节点编号. 记录传染到这个点最少再传染给几个人. 我们分类讨论, 先不考虑儿子节点还会继续传染的情况. 如果这个点没有儿子或者只有一个儿子, 那么最少再传染0个人. 否则传染节点数就是儿子数 - 1. 如果儿子节点还会继续传染, 那么我们就切断求出的f值最大的那个. f[now] = (\\sum_i^{i∈sons[now]}f[i] + 1) - (\\max_i^{i∈sons[now]}f[i]) - 1这个式子我实在不会写的更好了, sons代表节点的所有儿子. 看懂的话应该很快就能发现DP的错误在哪.结合这两个说明: 这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代 以致他们在一个疾病传播周期内，只能设法切断一条传播途径 单独看好像还是找不出这个DP的错误.然后我给出一张图. 正解应该是4, 然后DP竟跑出更优解3…其实是因为他在同一个疾病传播周期内切断了两条.DP将会先切断2, 然后切断7和8. 然而7和8在同一个传播周期内, 所以不能同时切断. 这就是DP的错误, 不符合题目要求. 然后就只能考虑搜索, 因为DP的启发, 就很容易想到按深度来搜索了. 代码错误DP代码(40分): 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int n, p, sums, f[301], head[301], edptr= 1;int tmpx, tmpy;struct edge { int to, nexty;} eds[1001];void add(int a, int b) { eds[edptr].to= b, eds[edptr].nexty= head[a]; head[a]= edptr++; return;}void dp(int nown, int fa) { int sons= 0, maxs= 0, tot= 0; for(int i= head[nown], to; i; i= eds[i].nexty) { to= eds[i].to; if(to == fa) continue; dp(to, nown); ++sons, maxs= max(maxs, f[to]), tot+= f[to]; } if(sons &gt;= 2) f[nown]= tot - maxs + sons - 1; return;}int main() { cin &gt;&gt; n &gt;&gt; p; for(int i= 0; i &lt; p; i++) { cin &gt;&gt; tmpx &gt;&gt; tmpy; add(tmpx, tmpy), add(tmpy, tmpx); } dp(1, -1); cout &lt;&lt; f[1] + 1 &lt;&lt; endl; return 0;} 正解搜索代码(100分): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;int n, p, head[301], edptr= 1;int tmpx, tmpy;struct edge { int to, nexty;} eds[1001];void add(int a, int b) { eds[edptr].to= b, eds[edptr].nexty= head[a]; head[a]= edptr++; return;}int dep[301], f[301], cutd[301];vector&lt; int &gt; node[302];void cut(int nown, int s) { cutd[nown]= s; for(int i= head[nown], to; i; i= eds[i].nexty) { to= eds[i].to; if(to != f[nown]) cut(to, s); } return;}void dfs1(int nown, int fa) { dep[nown]= dep[fa] + 1, f[nown]= fa; node[dep[nown]].push_back(nown); for(int i= head[nown], to; i; i= eds[i].nexty) { to= eds[i].to; if(to != fa) dfs1(to, nown); } return;}int ans= 0x3f3f3f3f;void dfs2(int deep, int cost) { if(cost &gt;= ans) return; int notsolve= 0; for(int i= 0; i &lt; (int)node[deep].size(); i++) if(!cutd[node[deep][i]]) ++notsolve; if(!notsolve) { ans= cost; return; } for(int i= 0; i &lt; (int)node[deep].size(); i++) { if(cutd[node[deep][i]]) continue; cut(node[deep][i], 1); dfs2(deep + 1, cost + notsolve - 1); cut(node[deep][i], 0); } return;}int main() { cin &gt;&gt; n &gt;&gt; p; for(int i= 0; i &lt; p; i++) { cin &gt;&gt; tmpx &gt;&gt; tmpy; add(tmpx, tmpy), add(tmpy, tmpx); } dfs1(1, 0), dfs2(2, 1); cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019-04/24-luogu1041/"},{"title":"LuoguP1456 - Monkey King","text":"【LuoguP1456】Monkey King题目链接: https://www.luogu.org/problem/P1456 前言左偏树真是我见过最好写的（高级？）数据结构。 分析这题其实就是个板子题。 看题意发现要维护大根堆，然后还有合并操作，那直接上左偏树。 话说左偏树找根的时候需要路径压缩，不然会被卡。所以直接上并查集，这样复杂度就正确了。 假设 X 和 Y 打架，我们先找他们的根 FX 和 FY 就是最牛叉的朋友，如果是一个人就输出-1，否则给 FX 和 FY的值都减半。 然后合并 FX 和 FY 的左右子树，视为将 FX 、FY 删去。 最后再把减半后的值当做一个子树再插入就完成了。 提醒一下，这题多组数据，我第一次交就被坑了。 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int n, m, v[100005], f[100005], l[100005], r[100005], d[100005];int tmpx, tmpy;inline int getf(int x) { return f[x] == x ? x : f[x]= getf(f[x]);}int merge(int x, int y) { if(!x || !y) return x + y; if(v[x] &lt; v[y]) swap(x, y); r[x]= merge(r[x], y), f[l[x]]= f[r[x]]= f[x]= x; if(d[r[x]] &gt; d[l[x]]) swap(r[x], l[x]); d[x]= d[r[x]] + 1; return x;}int solve(int x, int y) { x= getf(x), y= getf(y); if(x == y) return -1; v[x]&gt;&gt;= 1, v[y]&gt;&gt;= 1; int newx= merge(l[x], r[x]), newy= merge(l[y], r[y]); l[x]= r[x]= l[y]= r[y]= d[x]= d[y]= 0; newx= merge(newx, x), newy= merge(newy, y), newx= merge(newx, newy); return v[newx];}int main() { while(cin &gt;&gt; n) { for(int i= 1; i &lt;= n; i++) cin &gt;&gt; v[i], f[i]= i, l[i]= r[i]= d[i]= 0; cin &gt;&gt; m; for(int i= 1; i &lt;= m; i++) { cin &gt;&gt; tmpx &gt;&gt; tmpy; cout &lt;&lt; solve(tmpx, tmpy) &lt;&lt; endl; } } return 0;}","link":"/2019-08/20-luogu1456/"},{"title":"NOI2015 - 程序自动分析","text":"【LuoguP1955】【BZOJ4195】【NOI2015】程序自动分析题目链接1: https://www.luogu.org/problemnew/show/P1955题目链接2: https://www.lydsy.com/JudgeOnline/problem.php?id=4195 引言最近变得越来越颓废. 介于好长时间没更新博客, 强行水一篇题解. 这道题没看题解15分钟就A了, 真的有点水了… 分析题意大概就是有 N 个关系, 每个代表X1 = X2 或者 X1 ≠ X2, 求出这些关系能不能成立. 很容易就想到并查集, 先将相等的X合并, 然后判断不等关系的两个变量在不在一个并查集里就行了.那么就只需要排下序, 先进行合并操作再去判断. 判断不等关系过程中发现X1和X2在同一个并查集里, 那直接输出NO就行了. 然而X的下标可能会很大. 所以考虑离散化, 那么肯定直接上map. 输入的时候就离散化, 然后排个序, 打完合并和查询就AC了. 不过map常数巨大, 需要开O2稳过. 代码评测详情（O2）:Accepted 100用时: 1623ms / 内存: 11960KB 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;int t, n, f[200001], mptr, cnt, flag;struct date { int x, y, d; bool operator&lt;(const date &amp;d2) const { return d &gt; d2.d; }} dat[100001];int query(int x) { if(f[x] == x) return x; return f[x]= query(f[x]);}map&lt; int, int &gt; m;int main() { scanf(\"%d\", &amp;t); while(t--) { scanf(\"%d\", &amp;n); mptr= cnt= flag= 0; m.clear(); for(int i= 1; i &lt;= n; i++) { scanf(\"%d%d%d\", &amp;dat[i].x, &amp;dat[i].y, &amp;dat[i].d); if(!m.count(dat[i].x)) m[dat[i].x]= ++mptr; if(!m.count(dat[i].y)) m[dat[i].y]= ++mptr; dat[i].x= m[dat[i].x], dat[i].y= m[dat[i].y]; cnt+= dat[i].d; } sort(dat + 1, dat + n + 1); for(int i= 1; i &lt;= mptr; i++) f[i]= i; for(int i= 1; i &lt;= cnt; i++) { int fx= query(dat[i].x); f[query(dat[i].y)]= fx; } for(int i= cnt + 1; i &lt;= n; i++) { if(query(dat[i].x) == query(dat[i].y)) { printf(\"NO\\n\"); flag= 1; break; } } if(!flag) printf(\"YES\\n\"); } return 0;}","link":"/2019-03/31-luogu1955/"},{"title":"NOI2014 - 起床困难综合症","text":"【LuoguP2114】【BZOJ3668】【UOJ2】【VijosP1864】【NOI2014】起床困难综合症题目链接1: https://www.luogu.org/problemnew/show/P2114题目链接2: https://www.lydsy.com/JudgeOnline/problem.php?id=3668题目链接3: http://uoj.ac/problem/2题目链接4: https://vijos.org/p/1864 前言用了一个原创的做法, 模拟配合搜索, 非常玄学的过了这道题. 好像还没有这种做法的题解. 分析题意比较好理解, 当我看到这句话: 最终受到的伤害为对方初始攻击力x依次经过所有n扇防御门后转变得到的攻击力 依次经过N扇门是重点, 大大降低了这道题的难度. 由此想到最为暴力的方法, 从1到M枚举每一个数, 然后模拟N个操作, 算出每个数最后的伤害取个最大. 复杂度$ O(NM) $ 太大了. 然后考虑到位运算的性质, 我们只需要求出每一个二进制位上的变化就行了, 然后再把这些位组合起来, 求出一个初始不大于M但最终最大的数. 这个组合可以用搜索, 复杂度大概是 $ O(N \\log t + t) $ 看数据范围, $\\log t$ 比30小, 我使用一个数组$ num[31][2] $, 第一维代表二进制的位数, 第二维代表初始为 0 还是 1, 初始化这个数组. 然后可以$ O(n \\log t) $ 在线预处理, 直接模拟就行了. 预处理后的num数组就是每一个二进制位的变化. 然后就是求最终那个数, 因为M不是一个二的次幂, 所以不能循环求解, 但是可以用搜索. 如果学过01Trie, 上面的操作可以和它很相似, 求异或最大和本题的搜索的思路也类似. 然后加个条件判断和最优化剪枝就能完美通过本题了. 然后开int貌似会炸, 需要开long long, 但是最终答案应该是不会超int. 代码未吸氧评测详情: Accepted 100 用时: 371ms / 内存: 932KB 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;limits.h&gt;using namespace std;#define int long longint n, m, tmpx, num[32][2];char tmps[4];int ans= -1;void dfs(int nown, int total, int tmpans) { if(total &gt; m || tmpans &lt;= ans) return; if(nown == -1) { ans= tmpans; return; } dfs(nown - 1, total, tmpans + (num[nown][0] &lt;&lt; nown)); dfs(nown - 1, total + (1 &lt;&lt; nown), tmpans + (num[nown][1] &lt;&lt; nown)); return;}signed main() { cin &gt;&gt; n &gt;&gt; m; for(int i= 0; i &lt; 31; i++) num[i][1]= 1; for(int i= 0; i &lt; n; i++) { cin &gt;&gt; tmps &gt;&gt; tmpx; for(int j= 0; j &lt; 31; j++) { int ch= (tmpx &gt;&gt; j) &amp; 1; if(tmps[0] == 'A') num[j][0]&amp;= ch, num[j][1]&amp;= ch; else if(tmps[0] == 'O') num[j][0]|= ch, num[j][1]|= ch; else num[j][0]^= ch, num[j][1]^= ch; } } dfs(30, 0, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019-04/27-luogu2114/"},{"title":"HAOI2011 - Problem b","text":"【LuoguP2522】【BZOJ2301】【HAOI2011】Problem b题目链接1: https://www.luogu.org/problem/P2522题目链接2: https://www.lydsy.com/JudgeOnline/problem.php?id=2301 前言机房很久前就人均会反演，今天我终于看懂是啥了。 然后把整除分块理解透彻！ 先做道最简单的题练练手，感谢莫比乌斯反演 - OI WIKI和大佬CTZ的帮助。 分析本题题目翻译成公式： \\sum_{x=a}^{b}\\sum_{y=c}^{d} [gcd(x,y)=k]可以按照二维前缀和的思想分治一下，先设 F(n,m) = \\sum_{i=1}^{n}\\sum_{j=1}^{m} [gcd(i,j)=k]那么 ans = F(b,d) - F(b,c-1) - F(a-1,d) + F(a-1,c-1)然后对F(n,m)进行化简，首先两边同除以K，至于可行性，记录一下大佬的亲自讲解 如果原式中$gcd(i,j)=k$，那么$i,j$一定是k的倍数，现在设 i = i' * k , j = j' * k那么一定$gcd(i’,j’)=1$，所以得出 F(n,m) = \\sum_{i=1}^{\\lfloor \\frac{n}{k} \\rfloor}\\sum_{j=1}^{\\lfloor \\frac{m}{k} \\rfloor} [gcd(i,j)=1]这就可以莫比乌斯反演了，首先记住一个通用公式 [gcd(i,j)=1] = \\sum_{d \\mid gcd(i,j)}\\mu(d)然后代入F(n,m)中 F(n,m) = \\sum_{i=1}^{\\lfloor \\frac{n}{k} \\rfloor}\\sum_{j=1}^{\\lfloor \\frac{m}{k} \\rfloor} \\sum_{d \\mid gcd(i,j)}\\mu(d)先默认$n &lt; m$，那么可知$d \\in [1,\\lfloor \\frac{n}{k} \\rfloor]$ 然后改变一下位置 F(n,m) = \\sum_{d=1}^{\\lfloor \\frac{n}{k} \\rfloor}\\mu(d)\\sum_{i=1}^{\\lfloor \\frac{n}{k} \\rfloor}[i \\mid p]\\sum_{j=1}^{\\lfloor \\frac{m}{k} \\rfloor}[j \\mid p]注意，右边是一个整体，后面的$[i\\mid d],[j\\mid d]$取1或0，也就是表示能否整除。 这样还能进一步化简，根据常识易得 \\sum_{i=1}^{n} i \\mid p = \\lfloor \\frac{n}{p} \\rfloor从而推出 F(n,m) = \\sum_{d=1}^{\\lfloor \\frac{n}{k} \\rfloor}\\mu(d)\\lfloor \\frac{n}{kd} \\rfloor{\\lfloor \\frac{m}{kd} \\rfloor}式子终于推完了，然后就是整除分块。 其实我一开始没看懂整除分块是因为不知道有啥用，其实是用来$O(\\sqrt{n})$求这个式子 \\sum_{i=1}^{n} \\lfloor \\frac{i}{p} \\rfloor这样就好说了，我们知道某些$\\lfloor \\frac{i}{p} \\rfloor$的值是相等的，并且这些项在一个连续区间$[l,r]$内。 所以枚举时找一个右端点$r$，直接计算$[i,r]$这个区间的结果，这个$r= \\lfloor \\frac{n}{\\lfloor \\frac{n}{i} \\rfloor} \\rfloor$。 具体证明不难，数论分块 - OI WIKI有略证。 然后就写代码，还需要写莫比乌斯函数筛、前缀和。 这个莫比乌斯函数筛我有待研究。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;stdio.h&gt;#define MAXA 50001using namespace std;int miu[50005], notzs[50005], zs[50005], sum[50005];void shai() { notzs[1]= 1, miu[1]= 1; for(int i= 2; i &lt;= MAXA; i++) { if(!notzs[i]) miu[i]= -1, zs[++zs[0]]= i; for(int j= 1; j &lt;= zs[0] &amp;&amp; i * zs[j] &lt;= MAXA; j++) { notzs[i * zs[j]]= 1; if(i % zs[j] == 0) { miu[i * zs[j]]= 0; break; } miu[i * zs[j]]= -miu[i]; } } for(int i= 1; i &lt;= MAXA; i++) sum[i]= sum[i - 1] + miu[i]; return;}int query(int n, int m, int k) { int res= 0; n/= k, m/= k; if(n &gt; m) swap(n, m); for(int i= 1, j; i &lt;= n; i= j + 1) { j= min(n / (n / i), m / (m / i)); res+= (sum[j] - sum[i - 1]) * (n / i) * (m / i); } return res;}#define query(x, y) query(x, y, k)int t;int main() { shai(); cin &gt;&gt; t; int a, b, c, d, k; while(t--) { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; k; cout &lt;&lt; query(b, d) - query(b, c - 1) - query(a - 1, d) + query(a - 1, c - 1) &lt;&lt; endl; } return 0;} 后记然后你还可以把【LuoguP3455】【POI2007】ZAP-Queries 一块通过了，只需要改一下输入输出。","link":"/2019-09/02-luogu2522/"},{"title":"NOIP2015 - 斗地主增强版","text":"【NOIP2015】【LuoguP2540】斗地主增强版题目链接: https://www.luogu.org/problem/P2540 前言暴力出奇迹，我是搜索小名士。 早在一年前就用贪心完成了普通版，然后现在忘了。 所以重新写一遍这道题，并且提高难度做增强版。看了仅剩的智商，我选择搜索。 分析其实我一开始没有想着去写100分的代码，因为爆搜的复杂度太大，然后这题好像我只会爆搜。 第一步首先，很容易想到一种最纯粹的爆搜。每层都将当前剩余牌可行的情况全部枚举判断，然后打出一种可行的牌进入下一层继续搜索。 1搜索是盲目的，我们考虑剪枝。 ——某金牌教练 一个剪枝是搜索必备，如果当前答案大于或等于已知的最小答案，我们接下来的搜索一定不会更新答案，所以回到上一层。 然后再继续想，可以加一个启发式剪枝，计算打出所有剩余牌的最大出牌次数。 用肉眼就能推出，一副牌的最大出牌次数就是牌的数码种类数，两个王在此可以算一种。然后我们计算出当前最大出牌次数加上当前已出牌次数去更新答案，这样就会剪去接下来的一些较差的出牌方法。 第二步上面的方法必不能通过本题，不需要尝试也能猜测。所以还要继续剪枝。 再稍微思考一下，我们每层搜索将全部出牌方法都枚举一遍过于暴力。我们发现，有些出牌方法自始至终永远不可行，并且可行的出牌方法一定越来越少。然后就想到了预处理，我们预处理出最开始的手牌的可行出牌方法。 这里我的代码极其鬼畜，可能对代码能力有些要求。我用了一些自认为省空间，用起来舒服的方法。将可行方法的信息写成结构体，就不演示，代码中在讲讲。 最关键的是，我们要计算每种方法的出牌数量，可用来后续我们继续优化。 这些代码全部可在输入后搜索前执行，我是将这些可行方法放到了vector中。在搜索时，枚举vector的所有元素。再进行一次针对性判断，也就是判断需要打的那几张牌就够了。 第三步我们说记录了每种方法的出牌数量。那我们从大到小排序，这样大概能优化时间，我也不知道。 在这我们提个醒，如果你将王炸、对子、三张牌放入可行方法中，那你一定会TLE，因为我一开始就是这样。（实践出真知，但其实非加强版不需要，到这里已经通过了） 我们每层搜索，只枚举上一层搜索枚举没有枚举到的就行了，这是个小剪枝。如果当前方法的出牌数大于当前剩余数量，就直接枚举下一个出牌方法，这也可算上个小剪枝。然后还要再次判断当前剩余的牌下这种方法是否可行。 还有几个小的要点，我们不管是预处理，还是每层搜索都要用到一个小动态规划，用来求某个牌当左端点，可以连成（单、双、三）顺子的最大长度。鉴于这个题的难度，我相信大家都会这个小动归。 然后还有几个提示，四带二可以带两个相同数码的对子（俗称炸弹），同理，可以带两个相同数码的一张牌（俗称对子）。然后1当14，大小王当15、16比较好写代码。 经过多次提交更改调试，终于通过了本题。 代码不开O2两秒多通过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int T, n;struct PAI { int num, col;} ps[30];// 记录牌的数码，颜色（没啥用）#define SHUNZI 3#define SANDAI 4#define SIDAI 5//顺子、三带、四带struct CP { // 记录出牌方法的信息 int typ, l, r, k1, k2, siz; // typ 为宏定义的值 // siz 为出牌数量 // l r 多种使用。l：顺子左端点，其他为最多的那张牌。r：顺子右端点，其他为少的那张牌需要的个数 // k1 k2 三带、四带使用，表示附带哪一（两）张牌。 CP(int typ, int siz, int l= 0, int r= 0, int k1= 0, int k2= 0) { this-&gt;typ= typ, this-&gt;siz= siz, this-&gt;l= l, this-&gt;r= r, this-&gt;k1= k1, this-&gt;k2= k2; } inline int operator&lt;(const CP &amp;c2) const { return siz &gt; c2.siz; }};int pai[20], bestans, us3[20], us2[20], us1[20];vector&lt; CP &gt; v;void dfs(int nown, int nowa, int ls) { if(nowa &gt;= bestans) return; // 小剪枝 bestans= min(bestans, nowa + nown); // 更新答案，全部单打（没什么用） if(!nown) return; int res= 0, us[4][20]; memset(us, 0, sizeof(us)); for(int i= 2; i &lt;= 16; i++) res+= (pai[i] != 0); if(pai[15] &amp;&amp; pai[16]) --res; // 15、16为大小王，主程序中有，大小王可以王炸 bestans= min(bestans, nowa + res); // 再次更新答案（剪枝） for(int i= 14, cnt= 0; i &gt;= 2; i--) { if(pai[i] &lt; 1) continue; us[1][i]= us[1][i + 1] + 1; if(pai[i] &lt; 2) continue; us[2][i]= us[2][i + 1] + 1; if(pai[i] &lt; 3) continue; us[3][i]= us[3][i + 1] + 1; } // DP出可行的顺子长度 for(int i= ls; i &lt; v.size(); i++) { if(v[i].siz &gt; nown) continue; switch(v[i].typ) { case SHUNZI: { if(v[i].r - v[i].l + 1 &gt; us[v[i].k1][v[i].l]) break; for(int j= v[i].l; j &lt;= v[i].r; j++) pai[j]-= v[i].k1; dfs(nown - v[i].siz, nowa + 1, i + 1); for(int j= v[i].l; j &lt;= v[i].r; j++) pai[j]+= v[i].k1; // 判断顺子 break; } case SANDAI: { if(pai[v[i].l] &lt; 3 || pai[v[i].k1] &lt; v[i].r) break; pai[v[i].l]-= 3, pai[v[i].k1]-= v[i].r; dfs(nown - v[i].siz, nowa + 1, i + 1); pai[v[i].l]+= 3, pai[v[i].k1]+= v[i].r; // 判断三带 break; } case SIDAI: { if(pai[v[i].l] &lt; 4) break; if(pai[v[i].k1] &lt; 1 || pai[v[i].k2] &lt; 1) break; if(v[i].r == 2 &amp;&amp; (pai[v[i].k1] &lt; 2 || pai[v[i].k2] &lt; 2)) break; // 都需要两张 if(v[i].r == 2 &amp;&amp; v[i].k1 == v[i].k2 &amp;&amp; pai[v[i].k1] &lt; 4) break; // 两对相同数码 if(v[i].r == 1 &amp;&amp; v[i].k1 == v[i].k2 &amp;&amp; pai[v[i].k1] &lt; 2) break; // 两张相同数码 pai[v[i].l]-= 4; pai[v[i].k1]-= v[i].r; pai[v[i].k2]-= v[i].r; dfs(nown - v[i].siz, nowa + 1, i + 1); pai[v[i].l]+= 4; pai[v[i].k1]+= v[i].r; pai[v[i].k2]+= v[i].r; // 判断四带 } default: break; } } return;}int main() { scanf(\"%d%d\", &amp;T, &amp;n); while(T--) { memset(pai, 0, sizeof(pai)), bestans= 0x3f3f3f3f; for(int i= 1; i &lt;= n; i++) { scanf(\"%d%d\", &amp;ps[i].num, &amp;ps[i].col); if(ps[i].num == 1) ps[i].num= 14; // 1 当 14 if(ps[i].num == 0) ps[i].num= ps[i].col + 14; // 大小王当15、16 ++pai[ps[i].num]; } memset(us3, 0, sizeof(us3)), memset(us2, 0, sizeof(us2)), memset(us1, 0, sizeof(us1)); v.clear(); for(int i= 14; i &gt;= 3; i--) { if(pai[i] &lt; 1) continue; us1[i]= us1[i + 1] + 1; if(pai[i] &lt; 2) continue; us2[i]= us2[i + 1] + 1; if(pai[i] &lt; 3) continue; us3[i]= us3[i + 1] + 1; } // DP出顺子长度 for(int i= 2; i &lt;= 16; i++) { for(int j= 5; j &lt;= us1[i]; j++) v.push_back(CP(SHUNZI, j, i, i + j - 1, 1)); for(int j= 3; j &lt;= us2[i]; j++) v.push_back(CP(SHUNZI, j * 2, i, i + j - 1, 2)); for(int j= 2; j &lt;= us3[i]; j++) v.push_back(CP(SHUNZI, j * 3, i, i + j - 1, 3)); // i 当左端点的顺子 if(pai[i] &lt; 3) continue; for(int j= 2; j &lt;= 16; j++) { if(i == j || !pai[j]) continue; v.push_back(CP(SANDAI, 4, i, 1, j)); if(pai[j] &lt; 2) continue; v.push_back(CP(SANDAI, 5, i, 2, j)); } // 三带 if(pai[i] &lt; 4) continue; for(int j= 2; j &lt;= 16; j++) { if(i == j || !pai[j]) continue; for(int k= j + 1; k &lt;= 16; k++) { if(i == k || !pai[k]) continue; v.push_back(CP(SIDAI, 6, i, 1, j, k)); if(pai[j] &lt; 2 || pai[k] &lt; 2) continue; v.push_back(CP(SIDAI, 8, i, 2, j, k)); } if(pai[j] == 4) v.push_back(CP(SIDAI, 8, i, 2, j, j)); if(pai[j] &gt; 2) v.push_back(CP(SIDAI, 6, i, 1, j, j)); } // 四带 } sort(v.begin(), v.end()); // 排序 dfs(n, 0, 0); cout &lt;&lt; bestans &lt;&lt; endl; } return 0;}","link":"/2019-09/20-luogu2540/"},{"title":"LuoguP2633 - Count on a tree","text":"【LuoguP2633】【SP10628】【BZOJ2588】Count on a tree 树上第 K 大题目链接1: https://www.luogu.org/problemnew/show/P2633题目链接2: https://www.lydsy.com/JudgeOnline/problem.php?id=2588题目链接3: https://www.luogu.org/problemnew/show/SP10628题目链接4: https://www.spoj.com/problems/COT/ 前言本来是打算做 TJOI2018 - 异或 那道题的, 然后又看到这道题, 好像做这道题有助于那道题…然后就开始干 分析这道题像是组合模板题…用倍增LCA + 主席树, 直接套模板就行了. 有一些需要注意的东西, 边的数组最好开大一点, 不然容易RE, 哪个算法写炸了也容易RE, 所以需要小心谨慎的写代码, 然而Ciyang的倍增写挂了… 主席树我写的指针版, 好像很罕见, 强烈安利, 虽然和数组版没有多大的区别. 对于这道题, 先预处理出LCA, 然后建个树（数组版不需要） 查询时把$ x $和$ y $之间的链提出来, 主席树上存的是前缀和, 那么就需要先求出$ lca(x,y) $ 再根据数学上的某些原理（容斥?）求出 Sum(x,y) = sum(x) + sum(y) - sum(lca(x,y)) - sum(lca(x,y)) - sum(f[lca(x,y)])$ f[x] $ 代表 x 的父节点, 然后直接套主席树板子就行了 推荐两个STL必备黑科技, unique 和 lower_bound, 前者那个是给有序数组去重, 后者是有序数组二分查找. 一般都会了, 不会的百度把… 如果出现RE, 找不到原因, 可以去交这道题, 去掉强制在线, 如果WA就是算法问题了.再出现RE可能就是像我一样手残打错了一个数字之类的东西… 代码评测详情(未开O2): Accepted 100 用时: 1765ms / 内存: 76648KB 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;inline int read() { int e= 0, f= 1; char ch= getchar(); while(ch &lt; '0' || ch &gt; '9') { if(ch == '-') f= -1; ch= getchar(); } while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') e= e * 10 + ch - '0', ch= getchar(); return e * f;}// READint n, m, d, vi[100005], lv[100005], edptr= 1, head[100005], tmpx, tmpy, tmpz;struct edge { int to, nexty;} eds[400001];// 其实可以 100005 * 2void add(int a, int b) { eds[edptr].to= b, eds[edptr].nexty= head[a]; head[a]= edptr++; return;}// edgestruct NODE { NODE *l, *r; int v, sum;} * root[800005];// 其实可以 100005NODE *build(int l, int r) { NODE *nptr= new NODE(); if(l != r) { int mid= (l + r) &gt;&gt; 1; nptr-&gt;l= build(l, mid), nptr-&gt;r= build(mid + 1, r); } return nptr;}NODE *update(int l, int r, int c, NODE *pre) { NODE *nptr= new NODE(); nptr-&gt;l= pre-&gt;l, nptr-&gt;r= pre-&gt;r, nptr-&gt;sum= pre-&gt;sum + 1; if(l != r) { int mid= (l + r) &gt;&gt; 1; if(c &lt;= mid) nptr-&gt;l= update(l, mid, c, pre-&gt;l); else nptr-&gt;r= update(mid + 1, r, c, pre-&gt;r); } return nptr;}int query(NODE *ml, NODE *mr, NODE *xl, NODE *xr, int l, int r, int k) { if(l == r) return l; int qsum= mr-&gt;l-&gt;sum + ml-&gt;l-&gt;sum - xl-&gt;l-&gt;sum - xr-&gt;l-&gt;sum; int mid= (l + r) &gt;&gt; 1; if(qsum &gt;= k) return query(ml-&gt;l, mr-&gt;l, xl-&gt;l, xr-&gt;l, l, mid, k); return query(ml-&gt;r, mr-&gt;r, xl-&gt;r, xr-&gt;r, mid + 1, r, k - qsum);}// treeint deep[100005], f[100005][21];void dfs(int nown, int fa) { deep[nown]= deep[fa] + 1; f[nown][0]= fa; for(int i= 0; i &lt; 20; i++) f[nown][i + 1]= f[f[nown][i]][i]; // 从0开始...Ciyang写挂了,写成从1开始,然后交了好多遍也没改对 for(int i= head[nown], to; i; i= eds[i].nexty) { to= eds[i].to; if(to == fa) continue; dfs(to, nown); } return;}void dfs2(int nown) { root[nown]= update(1, n, lv[nown], root[f[nown][0]]); for(int i= head[nown], to; i; i= eds[i].nexty) { to= eds[i].to; if(to == f[nown][0]) continue; dfs2(to); } return;}int lca(int x, int y) { if(deep[x] &lt; deep[y]) swap(x, y); for(int i= 19; i &gt; -1; i--) { if(deep[f[x][i]] &gt;= deep[y]) x= f[x][i]; if(x == y) return x; } for(int i= 19; i &gt; -1; i--) if(f[x][i] != f[y][i]) x= f[x][i], y= f[y][i]; return f[x][0];}// LCAint lastans= 0, tmpc;int main() { n= read(), m= read(); for(int i= 1; i &lt;= n; i++) vi[i]= read(), lv[i]= vi[i]; for(int i= 1; i &lt; n; i++) { tmpx= read(), tmpy= read(); add(tmpx, tmpy), add(tmpy, tmpx); } root[0]= build(1, n); sort(vi + 1, vi + n + 1); d= unique(vi + 1, vi + n + 1) - vi - 1; for(int i= 1; i &lt;= n; i++) lv[i]= lower_bound(vi + 1, vi + d + 1, lv[i]) - vi; dfs(1, 0); dfs2(1); while(m--) { tmpx= read(), tmpy= read(), tmpz= read(); tmpx^= lastans; tmpc= lca(tmpx, tmpy); lastans= vi[query(root[tmpx], root[tmpy], root[tmpc], root[f[tmpc][0]], 1, n, tmpz)]; printf(\"%d\\n\", lastans); } return 0;}// main","link":"/2019-02/18-luogu2633/"},{"title":"LuoguP3396 - 哈希冲突","text":"【LuoguP3396】哈希冲突题目链接: https://www.luogu.org/problemnew/show/P3396 前言话说快暑假了…但是好像没有几天假期啊。 然后期末考试之际做了找到题，发现暴力好像都能用分块优化。 分析读完题目，发现想不到任何复杂度较低思路。对于几乎不接触分块的我，数据范围似乎没有什么用。 然后就打开了题解，才知道可以根号算法（不指分块），不过我统一把用sqrt函数的解法都叫做分块。 暴力的复杂度大概是$ O(mn) $ ，每次查询我们都需要$ O(n) $ 来遍历数组，修改是$ O(1) $。如果预处理的话那更玄学，每次查询时$ O(1) $，而修改是$ O(n^2) $ ，那么很有可能变成$ O(n^2m) $算法。 所以考虑只预处理$ \\sqrt{n} $的模数，复杂度为$ O(n \\sqrt{n}) $。 对于查询，如果查询的模数不超过$ \\sqrt{n} $那么可以直接输出答案。如果模数超过$ \\sqrt{n} $，我们只需要枚举模$ p $后的结果，把他们加起来，那么复杂度仍为$ \\frac{n}{\\sqrt{n}} = \\sqrt{n} $。 对于修改，与预处理类似，还是只修改$ \\sqrt{n} $的模数，由于只是单点修改，所以少了一层循环，那么复杂度为$ O(\\sqrt{n}) $。 总复杂度最大是$ O((m + n)\\sqrt{n}) $，然后就可以写代码了，代码极为简单，感觉像是暴力。 代码1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;using namespace std;int n, m, nb, v[150001], sum[1500][1500], tmpx, tmpy;char cmd;int main() { cin &gt;&gt; n &gt;&gt; m, nb= sqrt(n); for(int i= 1; i &lt;= n; i++) cin &gt;&gt; v[i]; for(int i= 1; i &lt;= nb; i++) for(int j= 1; j &lt;= n; j++) sum[i][j % i]+= v[j]; while(m--) { cin &gt;&gt; cmd &gt;&gt; tmpx &gt;&gt; tmpy; if(cmd == 'A') { if(tmpx &lt;= nb) cout &lt;&lt; sum[tmpx][tmpy] &lt;&lt; endl; else { int ans= 0; for(int i= tmpy; i &lt;= n; i+= tmpx) ans+= v[i]; cout &lt;&lt; ans &lt;&lt; endl; } } else { for(int i= 1; i &lt;= nb; i++) sum[i][tmpx % i]= sum[i][tmpx % i] - v[tmpx] + tmpy; v[tmpx]= tmpy; } } return 0;} 后记因为之前根号算法做比较少，而这道题给我很大的启示，以后一些只能想到暴力的题可以尝试使用根号来优化。 听说这题不用根号，而使用1/3次方作为块的大小效率更高。但是不会证明，而且复杂度比较玄学，可能只适用这一道题的数据吧。","link":"/2019-07/09-luogu3396/"},{"title":"LuoguP2580 - 于是他错误的点名开始了","text":"【LuoguP2580】于是他错误的点名开始了题目链接: https://www.luogu.org/problemnew/show/P2580 前言这篇题解原来是我放到Luogu上的，打算搬过来，原地址: https://ciyang.blog.luogu.org/solution-p2580 当时是自己闲得无聊自创的算法，跑了最优解第3，Trie树中最快了 不过后来Luogu上的dalao告诉我这个是边压Trie树，因此人生失去意义 此题解非正常字典树,推荐先学习普通的字典树并了解指针的使用 代码还是之前的代码,名为Lumpy_Tnode. 简介树上的边存储字符串,代表节点的单独前缀. 写题解的上午有了灵感,然后根据思路模拟了一下,可行性挺高的.代码上比普通的复杂一些,我使用了指针. 按任意顺序插入abcd,abcde,bcde,bcdf四个字符串的Trie树长这样 红色节点表示已插入字符串的结尾节点 证明通过与比较普通指针版和非指针版Trie来证明一下可行性. 已知一个节点要保存26条边的指针 指针版Trie可使用动态内存,缺点是每个节点只保存一个字符,会有大量边的空指针来占用额外的内存,且new节点多了,内存分配常数较大. 为了减少常数,可以自己写内存池分配,但无论是什么数据,只要稍带随机性形成链,就会有很多只有一个子节点的节点,这无疑有25个空指针浪费内存. 非指针版常数小,但空间分配也是很大的问题,多了可能MLE,少了RE.然而仍有很多一条链的树,空间最大浪费N*25啊…先不说影响美观而且时间复杂度依然很高,毕竟查询也是O(N). 边压Trie的复杂度是会改变的,就是对一条链情况的优化,理论最大时间复杂度是O(N)带有一些常数,不考虑常数情况下,永远小于等于普通Trie. 边压Trie巧妙利用字符串指针,赋值、继承等操作只需要指针或长度变化就好了,因此插入最小复杂度是O(1),空间上也少了很多空指针. 太多证明不如一句代码,我放上代码继续分析. 解析节点的结构体,原来的char变成了length和字符串指针: 1234567891011121314151617#define clear(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(a)) struct Lumpy_Tnode { const char *pStr; //指向当前存储字符串首元素 int length, isEnd; //length存储字符串的长度 isEnd代表是否是结尾节点 Lumpy_Tnode *children[26]; //26个子节点 inline Lumpy_Tnode() { pStr= 0, length= isEnd= 0, clear(children); } inline Lumpy_Tnode(const char *str, int len, int end) { pStr= str, length= len, isEnd= end, clear(children); } //构造函数 } mNode; 插入操作使用递归和循环,判断比较多,先看代码(看起来常数很大) 1234567891011121314151617181920212223242526272829303132333435inline void insert(const char *str, int length, Lumpy_Tnode *bNode) { //str是指针,指向当前插入字符串的第一个元素 if(!length) { //字符串长度为0代表结尾 //其实是为了优化代码美观,当作递归边界 bNode-&gt;isEnd= 1; return; } int ch= str[0] - 'a'; if(bNode-&gt;children[ch]) { //子节点已存在 bNode= bNode-&gt;children[ch]; register int sptr= 0; while(sptr &lt; length &amp;&amp; sptr &lt; bNode-&gt;length &amp;&amp; bNode-&gt;pStr[sptr] == str[sptr]) ++sptr; //循环来找当前字符串和节点存储的字符串最长前缀 if(sptr != bNode-&gt;length) { //节点存储的字符串不是插入字符串的子串 Lumpy_Tnode *nNode= new Lumpy_Tnode(bNode-&gt;pStr + sptr, bNode-&gt;length - sptr, bNode-&gt;isEnd); //拆树,运用字符串指针连续地址的特性来操作 copy(nNode-&gt;children, bNode-&gt;children), clear(bNode-&gt;children); //继承原有子节点的各种信息 bNode-&gt;isEnd= 0, bNode-&gt;children[bNode-&gt;pStr[sptr] - 'a']= nNode; //清空原有节点,重新初始化 } bNode-&gt;length= sptr; //更新当前节点存储的字符串长度,从而更改当前存储的字符串 insert(str + sptr, length - sptr, bNode); } else bNode-&gt;children[ch]= new Lumpy_Tnode(str, length, 1); //不存在当前首字母的子节点,直接new并且赋值 //因为是指针操作,所以不需要O(n)复制字符串,理论上复杂度O(3)? return;} //调用方式:insert(插入字符串, 字符串长度, Trie根节点); 如果代码看懂了,第一反应可能认为指针操作有一些漏洞. 的确插入的字符串在插入后就不能进行改变了,所以就只要开一个char[N][K]的数组来保存输入的字符串,K为最长字符串的长度. 相比较空间复杂度总体仍然较小,其实是把原来每个节点存的char放到了一起,每个节点多了一个指针. 这其中其实有个很巧妙的事,树上的一条链可能指向的地址是连续的.仔细想了想,其实也有空间浪费,不管是节点上还是树上的最长公共前缀都只指向一个字符串,其他字符串中相同的字符占用的空间就浪费掉了,这句话不懂没事,因为这个浪费造成的影响很小. 如果代码都没看懂,还有图解: 解释一下图2: 比较ab和ac,最长公共前缀为a 新建一个字符串指针指向ab中b的节点,长度为1,继承ab的颜色和ab的子节点. 清空ab的子节点,颜色改为黑(黑表示不为结尾节点),ab的首字母b子节点指向b. 在我实现时,先更改长度使ab变为a,再向a中插入c. 因为没有首字母为c的子节点,直接new一个新的. 查找操作12345678910111213141516171819202122inline int find(const char *str, int length, Lumpy_Tnode *bNode) { if(!length) { //递归到查找的字符串长度为0 //判断当前节点是否为结尾,是否是第一次查询 if(bNode-&gt;isEnd == 1) return bNode-&gt;isEnd++; return bNode-&gt;isEnd; } int ch= str[0] - 'a'; if(bNode-&gt;children[ch]) { bNode= bNode-&gt;children[ch]; if(length &lt; bNode-&gt;length) return 0; //自带剪枝,若当前查找字符串长度小于当前公共前缀,那么字典树中不存在当前查找的字符串 register int sptr= 0; while(sptr &lt; bNode-&gt;length &amp;&amp; bNode-&gt;pStr[sptr] == str[sptr]) ++sptr; if(sptr != bNode-&gt;length) return 0; //最长公共前缀必须是当前查找的字符串的子串 return find(str + sptr, length - sptr, bNode); } return 0; //没有子节点,字典树中不存在当前查找的字符串} //调用方式:find(查询字符串, 字符串长度, Trie根节点); 比插入的代码简单多了,并且自带剪枝,所以比较快. 代码（开启O2） 用时: 127ms / 内存: 4248KB（关闭O2） 用时: 144ms / 内存: 4128KB 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;#define clear(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(a))struct Lumpy_Trie { struct Lumpy_Tnode { const char *pStr; int length, isEnd; Lumpy_Tnode *children[26]; inline Lumpy_Tnode() { pStr= 0, length= isEnd= 0, clear(children); } inline Lumpy_Tnode(const char *str, int len, int end) { pStr= str, length= len, isEnd= end, clear(children); } } mNode; inline void insert(const char *str, int length, Lumpy_Tnode *bNode) { if(!length) { bNode-&gt;isEnd= 1; return; } int ch= str[0] - 'a'; if(bNode-&gt;children[ch]) { bNode= bNode-&gt;children[ch]; register int sptr= 0; while(sptr &lt; length &amp;&amp; sptr &lt; bNode-&gt;length &amp;&amp; bNode-&gt;pStr[sptr] == str[sptr]) ++sptr; if(sptr != bNode-&gt;length) { Lumpy_Tnode *nNode= new Lumpy_Tnode(bNode-&gt;pStr + sptr, bNode-&gt;length - sptr, bNode-&gt;isEnd); copy(nNode-&gt;children, bNode-&gt;children), clear(bNode-&gt;children); bNode-&gt;isEnd= 0, bNode-&gt;children[bNode-&gt;pStr[sptr] - 'a']= nNode; } bNode-&gt;length= sptr; insert(str + sptr, length - sptr, bNode); } else bNode-&gt;children[ch]= new Lumpy_Tnode(str, length, 1); return; } inline int find(const char *str, int length, Lumpy_Tnode *bNode) { if(length == 0) { if(bNode-&gt;isEnd == 1) return bNode-&gt;isEnd++; return bNode-&gt;isEnd; } int ch= str[0] - 'a'; if(bNode-&gt;children[ch]) { bNode= bNode-&gt;children[ch]; if(length &lt; bNode-&gt;length) return 0; register int sptr= 0; while(sptr &lt; bNode-&gt;length &amp;&amp; bNode-&gt;pStr[sptr] == str[sptr]) ++sptr; if(sptr != bNode-&gt;length) return 0; return find(str + sptr, length - sptr, bNode); } return 0; }} t;char allstr[10001][51], tmp[51];int n;int main() { scanf(\"%d\", &amp;n); for(register int i= 0; i &lt; n; i++) { scanf(\"%s\", allstr[i]); t.insert(allstr[i], strlen(allstr[i]), &amp;t.mNode); } scanf(\"%d\", &amp;n); for(register int i= 0, j; i &lt; n; i++) { scanf(\"%s\", tmp); j= t.find(tmp, strlen(tmp), &amp;t.mNode); switch(j) { case 0: printf(\"WRONG\\n\"); break; case 1: printf(\"OK\\n\"); break; case 2: printf(\"REPEAT\\n\"); break; } } return 0;} 最需要注意的是输入的字符串insert后不能再更改那一块内存了不能更改了… 后续我写的常数可能挺大,希望dalao们试试各种卡常优化…","link":"/2019-02/16-luogu2580/"},{"title":"NOI2003 - 文本编辑器","text":"【LuoguP4008】【BZOJ1507】【NOI2003】文本编辑器 Editor题目链接1: https://www.luogu.org/problemnew/show/P4008题目链接2: https://www.lydsy.com/JudgeOnline/problem.php?id=1507 前言这题放在任务计划里已经有些时日了，又拿出来看了看题面。原本是练习Splay用的，但因为不够熟练和懒得缘故，一直不想动手写。看了题解，发现了一个思路简单，代码较为暴力的数据结构——“块状链表”。 然后就愉快的做（抄）完了，首先感谢@HenryHuang的题解，他的题解使我学习块状链表得到了很大帮助。 我才不会告诉你很久以前我以为这是STL中string的练手题。 分析首先这道题有一个光标，只需用一个变量就可以维护光标。 然后就只剩下Insert、Delete、Get操作了，一般我们都会想到平衡树（Splay），但是难理解且代码复杂。 首先我们都听说过甚至用过链表，STL中的list就是使用链表实现。这种数据结构只能$ O(1) $获得首节点和尾结点，需要逐个遍历才能获得中间的节点。 不过链表也有优点，由于它的结构为一条链，每个节点维护了前节点指针和后节点指针，因此向中间插入一个数的复杂度为$ O(1) $。 然而对于这道题，使用链表并不可行，数据范围太大。 还有一个最简单最常见的数据结构，名叫数组。这个数据结构支持$ O(1) $访问。STL中有封装好的类数组数据结构vector，其中有封装好的函数insert用来插入操作。 对于数组，插入操作只需要2次memcpy函数，一次赋值操作就能完成，但是复杂度是极高的。每次插入的理论最大复杂度是 $ O(\\frac{n}{2}) $ 那么这题就不能投机取巧了吗？万一把数组和链表通过一定方式结合起来，复杂度不就会均衡了吗？ 众所周知，优化暴力的方法有很多，其中分块（根号）算法就非常热门。那么我们让数组的大小$ \\sqrt{n} $，然后将这些数组通过链表链接起来，那复杂度不就均衡了吗。 这种数据结构就是我使用的——块状链表。首先是定义一个结构体，用来存储某一节点的信息。我们只需要维护一个指向下一元素指针即可。 题目中说明了最大数据范围： 所有 INSERT 插入的字符数之和不超过 2M（1M=1024*1024 字节） ，正确的输出文件长度不超过 3M 字节。 所以我设置每个块的大小为1300，其实块大小在一定范围内即可。在这范围内，块大小和效率只有微小的关系。 12345const int sqrtn= 1300;struct BLOCK { int siz, nxt; char ch[sqrtn &lt;&lt; 1];} b[sqrtn &lt;&lt; 2]; 内存池为了节点数组循环利用，学习原题解的做法，使用内存池。注意，程序开始时需要初始化内存池。 12345678int blocks[sqrtn &lt;&lt; 2], bp, cur;inline int newb() { return blocks[bp++];}inline void delb(int x) { blocks[--bp]= x; return;} 肯定会有人问，块状链表怎么维护呢？这是最核心的部分。 Split当某一个块较大时我们需要分裂成两个块。在某些操作（插入、删除等）时，我们可以先从光标位置分裂这个块，然后就可以很方便的对后面的内容进行操作。 1234567// x 代表块编号，p代表分裂的位置（相对于块x）void split(int x, int p) { if(x == -1 || p == b[x].siz) return; add(x, newb(), b[x].ch + p, b[x].siz - p); b[x].siz= p; return;} Add上面的split函数中用到了add，这个函数是用来在某一块后面插入一个块。但add函数用作插入，那样就不能维护块状链表的性质了。 add函数与链表的插入类似，只不过赋值变成了memcpy函数。 123456789// x 代表块编号// y 常为一个未初始的块// st 为块 y 中的内容// siz 为 st 的长度inline void add(int x, int y, char *st, int siz) { if(y != -1) b[y].nxt= b[x].nxt, b[y].siz= siz, memcpy(b[y].ch, st, siz); b[x].nxt= y; return;} Merge如果两个相邻的块都很小，那么维护时就要需要合并。我选择将靠后的块合并到靠前的块中，这样比较简单。 1234567// x 代表块的编号// y 代表合并到 x 的块的编号void merge(int x, int y) { memcpy(b[x].ch + b[x].siz, b[y].ch, b[y].siz); b[x].siz+= b[y].siz, b[x].nxt= b[y].nxt, delb(y); return;} 何时维护其实我学习的时候，一开始也对维护有些不解。虽然知道了如何维护，但没有具体的思路，不知道什么时候需要维护。 根据前人的题解，维护只需要部分维护，即在插入和删除操作之后，维护相关的块。只要保证相邻两块大小之和大于$ \\sqrt{n} $，每块大小不超过$ \\sqrt{n} $，并且不考虑当块较大时的分裂操作，可以保证块的数量控制在 $ [\\sqrt{n},\\sqrt{2n}] $ 范围内。 这里再次感谢@HenryHuang的题解所给予的帮助。 对于本题本题中有插入和删除操作，两者类似。先得到光标当前所属的块，将此块在光标位置分裂。 对于插入，N 代表要插入的字符串长度。我们在分裂的位置先插入$ \\frac{N}{\\sqrt{n}} $个长度为$ \\sqrt{n} $的块，剩下不足$ \\sqrt{n} $长度的再独自插入，因为思路简单就不做解释。然后判断大小合并分裂位置前的块$ x $与$ x $的next块，合并刚插入的最后一个块$ y $与$ y $的next块。 对于删除，N 代表要删除的长度。在分裂的位置后逐个删除回收即可，如果最后一个块的长度大于剩余删除数，就再次分裂最后一个块，然后删除。 这部分代码将最后给出，先给出遍历块查找当前光标位置的代码。 1234567// x 为要找的位置，// 因为 x 也是一个引用，最后将赋值为相对于块res的位置inline int pos(int &amp;x) { int res= 0; while(res != -1 &amp;&amp; b[res].siz &lt; x) x-= b[res].siz, res= b[res].nxt; return res;} 对于Get操作更简单，不需要分裂操作，我为了方便直接在函数中输出了。推荐学习者自行构思，有助于对块状链表的理解。 提示，此题读入较大，建议使用极速IO优化。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;struct IOBUF { struct { char buff[1 &lt;&lt; 24], *p, *pend; } in; struct { char buff[1 &lt;&lt; 24], *p; } out; IOBUF() { in.p= in.buff, out.p= out.buff, in.pend= in.buff + fread(in.buff, 1, 1 &lt;&lt; 24, stdin); } ~IOBUF() { fwrite(out.buff, 1, out.p - out.buff, stdout); }} IOB;#define getchar() (*(IOB.in.p++))#define putchar(c) (*(IOB.out.p++)= (c))int read() { int e= 0; char ch= getchar(); while(ch &lt; '0' || ch &gt; '9') ch= getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') e= e * 10 + ch - '0', ch= getchar(); return e;}const int sqrtn= 1300;struct BLOCK { int siz, nxt; char ch[sqrtn &lt;&lt; 1];} b[sqrtn &lt;&lt; 2];int blocks[sqrtn &lt;&lt; 2], bp, cur;inline void init() { for(int i= 1; i &lt; (sqrtn &lt;&lt; 2); i++) blocks[i]= i; b[0].nxt= -1, bp= 1; return;}inline int newb() { return blocks[bp++];}inline void delb(int x) { blocks[--bp]= x; return;}inline void add(int x, int y, char *st, int siz) { if(y != -1) b[y].nxt= b[x].nxt, b[y].siz= siz, memcpy(b[y].ch, st, siz); b[x].nxt= y; return;}inline int pos(int &amp;x) { // &amp;x int res= 0; while(res != -1 &amp;&amp; b[res].siz &lt; x) x-= b[res].siz, res= b[res].nxt; return res;}void split(int x, int p) { if(x == -1 || p == b[x].siz) return; add(x, newb(), b[x].ch + p, b[x].siz - p); b[x].siz= p; return;}void merge(int x, int y) { memcpy(b[x].ch + b[x].siz, b[y].ch, b[y].siz); b[x].siz+= b[y].siz, b[x].nxt= b[y].nxt, delb(y); return;}void insert(int w, int siz, char *st) { int nowp= pos(w); split(nowp, w); int nextp, fp= nowp; while(sqrtn &lt; siz) { nextp= newb(); add(nowp, nextp, st, sqrtn); st+= sqrtn, siz-= sqrtn, nowp= nextp; } nextp= newb(), add(nowp, nextp, st, siz); if(b[nextp].nxt != -1 &amp;&amp; b[nextp].siz + b[b[nextp].nxt].siz &lt; sqrtn) merge(nextp, b[nextp].nxt); if(b[fp].nxt != -1 &amp;&amp; b[fp].siz + b[b[fp].nxt].siz &lt; sqrtn) merge(fp, b[fp].nxt); return;}void erase(int w, int siz) { int nowp= pos(w); split(nowp, w); int nextp= b[nowp].nxt; while(siz &gt; b[nextp].siz) siz-= b[nextp].siz, b[nowp].nxt= b[nextp].nxt, delb(nextp), nextp= b[nowp].nxt; split(nextp, siz), b[nowp].nxt= b[nextp].nxt, delb(nextp); while(b[nowp].nxt != -1 &amp;&amp; b[nowp].siz + b[b[nowp].nxt].siz &lt; sqrtn) merge(nowp, b[nowp].nxt); return;}void get(int w, int siz) { int nowp= pos(w), mins; mins= min(siz, b[nowp].siz - w), siz-= mins; for(int i= w; i &lt; w + mins; i++) putchar(b[nowp].ch[i]); while(siz) { nowp= b[nowp].nxt, mins= min(siz, b[nowp].siz), siz-= mins; for(int i= 0; i &lt; mins; i++) putchar(b[nowp].ch[i]); } putchar('\\n'); return;}char readopt() { char ch= getchar(); while(ch != 'M' &amp;&amp; ch != 'I' &amp;&amp; ch != 'D' &amp;&amp; ch != 'G' &amp;&amp; ch != 'P' &amp;&amp; ch != 'N') ch= getchar(); return ch;}int m, n;char str[1048576];int main() { init(), m= read(); while(m--) { switch(readopt()) { case 'M': cur= read(); break; case 'P': --cur; break; case 'N': ++cur; break; case 'I': { n= read(); for(int i= 0; i &lt; n; i++) { str[i]= getchar(); if(str[i] &lt; 32 || str[i] &gt; 126) --i; } insert(cur, n, str); break; } case 'D': { n= read(); erase(cur, n); break; } case 'G': { n= read(); get(cur, n); break; } default: break; } } return 0;}","link":"/2019-07/11-luogu4008/"},{"title":"USACO17DEC - Haybale Feast","text":"【LuoguP4085】【USACO17DEC】Haybale Feast题目链接: https://www.luogu.org/problemnew/show/P4085 引言好像教练说要考线段树和树状数组, 然后看到了这个题 这道题可以练习各种数据结构的基础操作… 我就浪费了大把时间用各种算法来A这道题 分析先看这个 $ \\sum_{k=i}^{j} F_k \\geqslant M $ 这个一眼看上去就是前缀和了.静态的话直接普通的前缀和$ O(n) $ 预处理, $ O(1) $ 查询就行了,应该是时间复杂度最低的了. 至于这个 $ max(S_i,S_{i+1},…,S_{j-1},S_j) $ 维护方法就比较多了,可以用线段树,分块,ST表,我没有写树状数组,因为太麻烦了. 然后我就浪费了好多时间来用不同的算法A这道题… 这道题还有一个性质, 关于找i和j, 不需要 $ O(n^2) $ 的复杂度来枚举区间, 我给出下面这个式子 max(s_i, s_{i + 1}, s_{i + 2}) = m注: Sumf代表f数组的前缀和 那么我们可以用 $ O(logn) $ 的复杂度二分查询这个j了 我们其实不需要自己写二分查找,根据上面的不等式,移一下项,就变成了 Sumf_j >= m + sumf_i然后使用STL自带的lower_bound函数就可以了 维护区间最大值我建议写ST表, 毕竟静态查询时间复杂度 $ O(1) $, 你也可以写其他的, 我竟然写了三种数据结构. 代码这个代码是线段树 + 前缀和, 评测详情 418ms / 6MB ST_Table为ST表的代码, 评测详情 328ms / 9.53MB Sqrt为分块,实在没找到英文名, 评测详情 1049ms / 7.65MB m 和 前缀和要开long long, 其他的可以用int, 懒得话就全部 long long 吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;using namespace std;typedef long long ll;int n, f[100001], s[100001];ll m;inline int maxi(int a, int b) { return a &gt; b ? a : b;}inline int mini(int a, int b) { return a &lt; b ? a : b;}namespace PrefixSum {// prefixsum for fll sumf[100001];void init() { for(int i= 1; i &lt;= n; i++) sumf[i]= sumf[i - 1] + f[i]; return;}} // namespace PrefixSumnamespace ST_Table {// ST_Table for sint maxs[100001][18], _log2[100001];void init() { for(int i= 1; i &lt;= n; i++) maxs[i][0]= s[i], _log2[i]= _log2[i - 1] + (i &gt;= (1 &lt;&lt; (_log2[i - 1] + 1))); for(int j= 1; j &lt; 18; j++) for(int i= 1; i + (1 &lt;&lt; j) &lt;= n; i++) maxs[i][j]= maxi(maxs[i][j - 1], maxs[i + (1 &lt;&lt; (j - 1))][j - 1]); return;}int query(int l, int r) { int __log2= _log2[r - l + 1]; return maxi(maxs[l][__log2], maxs[r - (1 &lt;&lt; __log2) + 1][__log2]);}} // namespace ST_Tablenamespace Sqrt {// Sqrt for sint blocks, maxs[100001], block[100001], bl[100001], br[100001];void init() { blocks= sqrt(n); int cnt= n / blocks + (n % blocks &amp; 1); for(int i= 1; i &lt;= n; i++) block[i]= (i - 1) / blocks + 1; for(int i= 1; i &lt;= cnt; i++) bl[i]= (i - 1) * blocks + 1, br[i]= i * blocks; br[cnt]= mini(n, br[cnt]); for(int i= 1; i &lt;= cnt; i++) for(int j= bl[i]; j &lt;= br[i]; j++) maxs[i]= maxi(maxs[i], s[j]); return;}int query(int l, int r) { int x= block[l], y= block[r], ans= 0; for(int i= x + 1; i &lt; y; i++) ans= maxi(ans, maxs[i]); for(int i= l; i &lt;= br[x]; i++) ans= maxi(ans, s[i]); for(int i= bl[y]; i &lt;= r; i++) ans= maxi(ans, s[i]); return ans;}} // namespace Sqrtnamespace SegmentTree {// SegmentTree for sint maxs[100001 &lt;&lt; 2];void build(int nown, int l, int r) { if(l == r) { maxs[nown]= s[l]; return; } int mid= (l + r) &gt;&gt; 1; build(nown &lt;&lt; 1, l, mid); build(nown &lt;&lt; 1 | 1, mid + 1, r); maxs[nown]= maxi(maxs[nown &lt;&lt; 1], maxs[nown &lt;&lt; 1 | 1]); return;}int query(int nown, int l, int r, int ml, int mr) { if(ml &lt;= l &amp;&amp; r &lt;= mr) return maxs[nown]; int ans= 0, mid= (l + r) &gt;&gt; 1; if(mid &gt;= ml) ans= maxi(ans, query(nown &lt;&lt; 1, l, mid, ml, mr)); if(mid &lt; mr) ans= maxi(ans, query(nown &lt;&lt; 1 | 1, mid + 1, r, ml, mr)); return ans;}inline void init() { build(1, 1, n); return;}inline int query(int l, int r) { return query(1, 1, n, l, r);}} // namespace SegmentTreeint ans= 0x7f7f7f7f;int main() { scanf(\"%d%lld\", &amp;n, &amp;m); for(int i= 1; i &lt;= n; i++) scanf(\"%d%d\", f + i, s + i); PrefixSum::init(), SegmentTree::init(); for(int i= 1; i &lt;= n; i++) { ll r= lower_bound(PrefixSum::sumf + i, PrefixSum::sumf + n + 1, m + PrefixSum::sumf[i - 1]) - PrefixSum::sumf; if(r != n + 1) ans= mini(ans, SegmentTree::query(i, r)); } printf(\"%d\\n\", ans); return 0;}","link":"/2019-03/07-luogu4085/"},{"title":"LuoguP3709 - 大爷的字符串题","text":"【LuoguP3709】大爷的字符串题题目链接: https://www.luogu.org/problemnew/show/P3709 前言最近一个月是各种忙啊。先是准备了半个多月的合格考，然后终于回归了OI。最近一周又生病请假等就没有更新过题解。上次更新题解也是很久之前，因为中间有段时间颓废过度做项目，现在那个项目基本已经咕咕，因为懒得再下Visual Studio了。 这几天一直在做莫队，然后做到这道题，打算水篇题解。 分析这题可以说是语文阅读理解神题，丝毫看不懂出题人意图是什么。 根据出题人的解释，一句话概括如下: 给你 N 个数, M 次询问区间[l, r]中众数的出现次数 然后就非常容易，但是字符集数据范围1e9需要离散化，我直接边读入边使用map处理。 根据一些其他题解的提示，我们开一个cnt数组记录区间内某个数出现的次数，然后用cntt数组记录cnt数组中数出现的次数。 在区间扩大时ans和cnt数组取max，然后区间缩小时就判断cntt是否已经为0，如果是就让ans减一。当然不能忘了区间更改时cnt和cntt肯定都会有所改变。 代码评测详情(未开O2): Accepted 100 用时: 1634ms / 内存: 9740KB 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;map&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;using namespace std;int read() { int x= 0, f= 1; char ch= getchar(); while(ch &lt; '0' || ch &gt; '9') { if(ch == '-') f= -1; ch= getchar(); } while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') x= x * 10 + ch - '0', ch= getchar(); return x * f;}inline void write(int x) { if(x &lt; 0) x= -x, putchar('-'); if(x &gt; 9) write(x / 10); putchar('0' + x % 10); return;}int n, m, a[200001], mapptr, cnt[200001], cntt[200001], nowans, ans[200001], ns;map&lt; int, int &gt; mapping;struct QUERY { int id, l, r, bl; int operator&lt;(const QUERY &amp;q2) const { return bl == q2.bl ? r &lt; q2.r : l &lt; q2.l; }} qs[200001];inline void add(int x) { --cntt[cnt[x]]; ++cntt[++cnt[x]]; nowans= max(nowans, cnt[x]); return;}inline void del(int x) { --cntt[cnt[x]]; if(!cntt[cnt[x]] &amp;&amp; nowans == cnt[x]) --nowans; ++cntt[--cnt[x]]; return;}int main() { n= read(), m= read(), ns= sqrt(n); for(int i= 1; i &lt;= n; i++) { a[i]= read(); if(!mapping[a[i]]) mapping[a[i]]= ++mapptr; a[i]= mapping[a[i]]; } for(int i= 1; i &lt;= m; i++) qs[i].l= read(), qs[i].r= read(), qs[i].id= i, qs[i].bl= (qs[i].l - 1) / ns; sort(qs + 1, qs + m + 1); int l= 1, r= 0; for(int i= 1; i &lt;= m; i++) { while(l &lt; qs[i].l) del(a[l++]); while(l &gt; qs[i].l) add(a[--l]); while(r &gt; qs[i].r) del(a[r--]); while(r &lt; qs[i].r) add(a[++r]); ans[qs[i].id]= nowans; } for(int i= 1; i &lt;= m; i++) write(-ans[i]), putchar('\\n'); return 0;}","link":"/2019-07/01-luogu3709/"},{"title":"NOI2005 - 智慧珠游戏","text":"【LuoguP4205】【BZOJ1501】【NOI2005】智慧珠游戏题目链接1: https://www.luogu.org/problemnew/show/P4205题目链接2: https://www.lydsy.com/JudgeOnline/problem.php?id=1501 引言最近忙于各种事, 又有十天没写题解了, 好像这十天又变颓废了好多 实在学习不下去很酷很炫的算法, 特意找搜索模拟等类题, 然后看到了这道题 做题的时候教练还在说:”不要看不起搜索…” 然后因为看我做这道题, 旁边的大佬还作了一首诗 12345生命诚可贵搜索价更高若为暴力故二者皆可抛 --Steve_Braveman 分析我就直接把题目描述的图搬过来了 一眼看上去就直接劝退, 当然其实也没那么严重, 好像还是可做的 具体分析一下这道题, 所有的零件都允许旋转和翻转, 那么每种零件都有多种放置的方法 所以我们就可以画一下不同的方法, 可以在草稿纸上或者上画图 为了区别什么是不同的摆放方法, 就要确定搜索的方式, 我们枚举每一个点, 如果这个点当前没有被覆盖过, 那么我们就可以选择当前剩余的零件进行判断. 我选择零件最左上角的那个珠子来填当前这个点, 因此有这些种不同的摆放方式 123456789101112A: 4种B: 2种C: 8种D: 1种E: 4种F: 8种G: 4种H: 8种I: 8种J: 1种K: 4种L: 8种 加起来的确有很多种, 然后就开始写DFS了. 我写的还是比较暴力的, 暴力模拟, 只做了一些小的技巧. 在某次DFS种, 第一次判断某条件时就把他以一个变量存起来, 起一个较为直观的变量名, 然后等下次判断就可以直接判断这个变量了. 写的时候得有耐心, 确实是有想死的感觉. 写完后, 你还是AC不了这道题, 会有一个点TLE. 这个点是No solution…我先选择了卡时限, 到0.95s之后就输出无解 但是事实证明不可行, 因为clock函数效率不高, 许多点的耗时飙升, 并导致另一个本来有解的却输出了无解… 然后就考虑卡DFS次数, 我在本地试了一下, 10000000就不会错判无解了, 然后提交AC了 代码注释中A1代表A零件的第1种摆放方法, 以此类推 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;using namespace std;int chose[126], cnt;char tmc, inits[20][20];inline int getlimit(int nowx, int nowy) { return nowx &gt; 0 &amp;&amp; nowx &lt; 11 &amp;&amp; nowy &gt; 0 &amp;&amp; nowy &lt; nowx + 1;}int dfs(int nowx, int nowy) { if(++cnt &gt; 10000000) return false; if(nowx == 11) return true; if(nowy == nowx + 1) return dfs(nowx + 1, 1); if(inits[nowx][nowy] != '.') return dfs(nowx, nowy + 1); int right= (getlimit(nowx, nowy + 1) &amp;&amp; inits[nowx][nowy + 1] == '.'); int rdown= (getlimit(nowx + 1, nowy + 1) &amp;&amp; inits[nowx + 1][nowy + 1] == '.'); int down= (getlimit(nowx + 1, nowy) &amp;&amp; inits[nowx + 1][nowy] == '.'); int dleft= (getlimit(nowx + 1, nowy - 1) &amp;&amp; inits[nowx + 1][nowy - 1] == '.'); if(!chose['A']) { chose['A']= true, inits[nowx][nowy]= 'A'; // A1 if(right &amp;&amp; rdown) { inits[nowx][nowy + 1]= 'A', inits[nowx + 1][nowy + 1]= 'A'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx + 1][nowy + 1]= '.'; } // A2 if(down &amp;&amp; dleft) { inits[nowx + 1][nowy]= 'A', inits[nowx + 1][nowy - 1]= 'A'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy - 1]= '.'; } // A3 if(down &amp;&amp; rdown) { inits[nowx + 1][nowy]= 'A', inits[nowx + 1][nowy + 1]= 'A'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy + 1]= '.'; } // A4 if(right &amp;&amp; down) { inits[nowx][nowy + 1]= 'A', inits[nowx + 1][nowy]= 'A'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx + 1][nowy]= '.'; } chose['A']= false; } int ddown= (getlimit(nowx + 2, nowy) &amp;&amp; inits[nowx + 2][nowy] == '.'); int dddown= (getlimit(nowx + 3, nowy) &amp;&amp; inits[nowx + 3][nowy] == '.'); int rright= (getlimit(nowx, nowy + 2) &amp;&amp; inits[nowx][nowy + 2] == '.'); int rrright= (getlimit(nowx, nowy + 3) &amp;&amp; inits[nowx][nowy + 3] == '.'); if(!chose['B']) { chose['B']= true, inits[nowx][nowy]= 'B'; // B1 if(down &amp;&amp; ddown &amp;&amp; dddown) { inits[nowx + 1][nowy]= 'B', inits[nowx + 2][nowy]= 'B', inits[nowx + 3][nowy]= 'B'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 2][nowy]= '.', inits[nowx + 3][nowy]= '.'; } // B2 if(right &amp;&amp; rright &amp;&amp; rrright) { inits[nowx][nowy + 1]= 'B', inits[nowx][nowy + 2]= 'B', inits[nowx][nowy + 3]= 'B'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx][nowy + 2]= '.', inits[nowx][nowy + 3]= '.'; } chose['B']= false; } int rddown= (getlimit(nowx + 2, nowy + 1) &amp;&amp; inits[nowx + 2][nowy + 1] == '.'); int dlleft= (getlimit(nowx + 1, nowy - 2) &amp;&amp; inits[nowx + 1][nowy - 2] == '.'); int drright= (getlimit(nowx + 1, nowy + 2) &amp;&amp; inits[nowx + 1][nowy + 2] == '.'); int ddleft= (getlimit(nowx + 2, nowy - 1) &amp;&amp; inits[nowx + 2][nowy - 1] == '.'); if(!chose['C']) { chose['C']= true, inits[nowx][nowy]= 'C'; // C1 if(right &amp;&amp; rright &amp;&amp; down) { inits[nowx][nowy + 1]= 'C', inits[nowx][nowy + 2]= 'C', inits[nowx + 1][nowy]= 'C'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx][nowy + 2]= '.', inits[nowx + 1][nowy]= '.'; } // C2 if(right &amp;&amp; rdown &amp;&amp; rddown) { inits[nowx][nowy + 1]= 'C', inits[nowx + 1][nowy + 1]= 'C', inits[nowx + 2][nowy + 1]= 'C'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx + 1][nowy + 1]= '.', inits[nowx + 2][nowy + 1]= '.'; } // C3 if(down &amp;&amp; dleft &amp;&amp; dlleft) { inits[nowx + 1][nowy]= 'C', inits[nowx + 1][nowy - 1]= 'C', inits[nowx + 1][nowy - 2]= 'C'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy - 1]= '.', inits[nowx + 1][nowy - 2]= '.'; } // C4 if(down &amp;&amp; ddown &amp;&amp; rddown) { inits[nowx + 1][nowy]= 'C', inits[nowx + 2][nowy]= 'C', inits[nowx + 2][nowy + 1]= 'C'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 2][nowy]= '.', inits[nowx + 2][nowy + 1]= '.'; } // C5 if(down &amp;&amp; rdown &amp;&amp; drright) { inits[nowx + 1][nowy]= 'C', inits[nowx + 1][nowy + 1]= 'C', inits[nowx + 1][nowy + 2]= 'C'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy + 1]= '.', inits[nowx + 1][nowy + 2]= '.'; } // C6 if(right &amp;&amp; down &amp;&amp; ddown) { inits[nowx][nowy + 1]= 'C', inits[nowx + 1][nowy]= 'C', inits[nowx + 2][nowy]= 'C'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx + 1][nowy]= '.', inits[nowx + 2][nowy]= '.'; } // C7 if(right &amp;&amp; rright &amp;&amp; drright) { inits[nowx][nowy + 1]= 'C', inits[nowx][nowy + 2]= 'C', inits[nowx + 1][nowy + 2]= 'C'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx][nowy + 2]= '.', inits[nowx + 1][nowy + 2]= '.'; } // C8 if(down &amp;&amp; ddown &amp;&amp; ddleft) { inits[nowx + 1][nowy]= 'C', inits[nowx + 2][nowy]= 'C', inits[nowx + 2][nowy - 1]= 'C'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 2][nowy]= '.', inits[nowx + 2][nowy - 1]= '.'; } chose['C']= false; } if(!chose['D']) { chose['D']= true, inits[nowx][nowy]= 'D'; // D1 if(right &amp;&amp; down &amp;&amp; rdown) { inits[nowx + 1][nowy]= 'D', inits[nowx][nowy + 1]= 'D', inits[nowx + 1][nowy + 1]= 'D'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx][nowy + 1]= '.', inits[nowx + 1][nowy + 1]= '.'; } chose['D']= false; } int ddrright= (getlimit(nowx + 2, nowy + 2) &amp;&amp; inits[nowx + 2][nowy + 2] == '.'); int ddlleft= (getlimit(nowx + 2, nowy - 2) &amp;&amp; inits[nowx + 2][nowy - 2] == '.'); if(!chose['E']) { chose['E']= true, inits[nowx][nowy]= 'E'; // E1 if(down &amp;&amp; ddown &amp;&amp; rddown &amp;&amp; ddrright) { inits[nowx + 1][nowy]= 'E', inits[nowx + 2][nowy]= 'E', inits[nowx + 2][nowy + 1]= 'E', inits[nowx + 2][nowy + 2]= 'E'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 2][nowy]= '.', inits[nowx + 2][nowy + 1]= '.', inits[nowx + 2][nowy + 2]= '.'; } // E2 if(right &amp;&amp; rright &amp;&amp; down &amp;&amp; ddown) { inits[nowx][nowy + 1]= 'E', inits[nowx][nowy + 2]= 'E', inits[nowx + 1][nowy]= 'E', inits[nowx + 2][nowy]= 'E'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx][nowy + 2]= '.', inits[nowx + 1][nowy]= '.', inits[nowx + 2][nowy]= '.'; } // E3 if(right &amp;&amp; rright &amp;&amp; drright &amp;&amp; ddrright) { inits[nowx][nowy + 1]= 'E', inits[nowx][nowy + 2]= 'E', inits[nowx + 1][nowy + 2]= 'E', inits[nowx + 2][nowy + 2]= 'E'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx][nowy + 2]= '.', inits[nowx + 1][nowy + 2]= '.', inits[nowx + 2][nowy + 2]= '.'; } // E4 if(down &amp;&amp; ddown &amp;&amp; ddleft &amp;&amp; ddlleft) { inits[nowx + 1][nowy]= 'E', inits[nowx + 2][nowy]= 'E', inits[nowx + 2][nowy - 1]= 'E', inits[nowx + 2][nowy - 2]= 'E'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 2][nowy]= '.', inits[nowx + 2][nowy - 1]= '.', inits[nowx + 2][nowy - 2]= '.'; } chose['E']= false; } if(!chose['F']) { chose['F']= true, inits[nowx][nowy]= 'F'; // F1 if(right &amp;&amp; rright &amp;&amp; rrright &amp;&amp; rdown) { inits[nowx][nowy + 1]= 'F', inits[nowx][nowy + 2]= 'F', inits[nowx][nowy + 3]= 'F', inits[nowx + 1][nowy + 1]= 'F'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx][nowy + 2]= '.', inits[nowx][nowy + 3]= '.', inits[nowx + 1][nowy + 1]= '.'; } // F2 if(down &amp;&amp; ddown &amp;&amp; dddown &amp;&amp; dleft) { inits[nowx + 1][nowy]= 'F', inits[nowx + 2][nowy]= 'F', inits[nowx + 3][nowy]= 'F', inits[nowx + 1][nowy - 1]= 'F'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 2][nowy]= '.', inits[nowx + 3][nowy]= '.', inits[nowx + 1][nowy - 1]= '.'; } // F3 if(down &amp;&amp; dleft &amp;&amp; dlleft &amp;&amp; rdown) { inits[nowx + 1][nowy]= 'F', inits[nowx + 1][nowy - 1]= 'F', inits[nowx + 1][nowy - 2]= 'F', inits[nowx + 1][nowy + 1]= 'F'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy - 1]= '.', inits[nowx + 1][nowy - 2]= '.', inits[nowx + 1][nowy + 1]= '.'; } // F4 if(down &amp;&amp; ddown &amp;&amp; dddown &amp;&amp; rddown) { inits[nowx + 1][nowy]= 'F', inits[nowx + 2][nowy]= 'F', inits[nowx + 3][nowy]= 'F', inits[nowx + 2][nowy + 1]= 'F'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 2][nowy]= '.', inits[nowx + 3][nowy]= '.', inits[nowx + 2][nowy + 1]= '.'; } // F5 if(down &amp;&amp; dleft &amp;&amp; rdown &amp;&amp; drright) { inits[nowx + 1][nowy]= 'F', inits[nowx + 1][nowy - 1]= 'F', inits[nowx + 1][nowy + 1]= 'F', inits[nowx + 1][nowy + 2]= 'F'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy - 1]= '.', inits[nowx + 1][nowy + 1]= '.', inits[nowx + 1][nowy + 2]= '.'; } // F6 if(down &amp;&amp; ddown &amp;&amp; ddleft &amp;&amp; dddown) { inits[nowx + 1][nowy]= 'F', inits[nowx + 2][nowy]= 'F', inits[nowx + 2][nowy - 1]= 'F', inits[nowx + 3][nowy]= 'F'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 2][nowy]= '.', inits[nowx + 2][nowy - 1]= '.', inits[nowx + 3][nowy]= '.'; } // F7 if(right &amp;&amp; rright &amp;&amp; drright &amp;&amp; rrright) { inits[nowx][nowy + 1]= 'F', inits[nowx][nowy + 2]= 'F', inits[nowx + 1][nowy + 2]= 'F', inits[nowx][nowy + 3]= 'F'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx][nowy + 2]= '.', inits[nowx + 1][nowy + 2]= '.', inits[nowx][nowy + 3]= '.'; } // F8 if(down &amp;&amp; rdown &amp;&amp; ddown &amp;&amp; dddown) { inits[nowx + 1][nowy]= 'F', inits[nowx + 1][nowy + 1]= 'F', inits[nowx + 2][nowy]= 'F', inits[nowx + 3][nowy]= 'F'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy + 1]= '.', inits[nowx + 2][nowy]= '.', inits[nowx + 3][nowy]= '.'; } chose['F']= false; } if(!chose['G']) { chose['G']= true, inits[nowx][nowy]= 'G'; // G1 if(down &amp;&amp; right &amp;&amp; rright &amp;&amp; drright) { inits[nowx + 1][nowy]= 'G', inits[nowx][nowy + 1]= 'G', inits[nowx][nowy + 2]= 'G', inits[nowx + 1][nowy + 2]= 'G'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx][nowy + 1]= '.', inits[nowx][nowy + 2]= '.', inits[nowx + 1][nowy + 2]= '.'; } // G2 if(right &amp;&amp; rdown &amp;&amp; rddown &amp;&amp; ddown) { inits[nowx][nowy + 1]= 'G', inits[nowx + 1][nowy + 1]= 'G', inits[nowx + 2][nowy + 1]= 'G', inits[nowx + 2][nowy]= 'G'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx + 1][nowy + 1]= '.', inits[nowx + 2][nowy + 1]= '.', inits[nowx + 2][nowy]= '.'; } // G3 if(down &amp;&amp; rdown &amp;&amp; drright &amp;&amp; rright) { inits[nowx + 1][nowy]= 'G', inits[nowx + 1][nowy + 1]= 'G', inits[nowx + 1][nowy + 2]= 'G', inits[nowx][nowy + 2]= 'G'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy + 1]= '.', inits[nowx + 1][nowy + 2]= '.', inits[nowx][nowy + 2]= '.'; } // G4 if(right &amp;&amp; down &amp;&amp; ddown &amp;&amp; rddown) { inits[nowx][nowy + 1]= 'G', inits[nowx + 1][nowy]= 'G', inits[nowx + 2][nowy]= 'G', inits[nowx + 2][nowy + 1]= 'G'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx + 1][nowy]= '.', inits[nowx + 2][nowy]= '.', inits[nowx + 2][nowy + 1]= '.'; } chose['G']= false; } if(!chose['H']) { chose['H']= true, inits[nowx][nowy]= 'H'; // H1 if(right &amp;&amp; rright &amp;&amp; down &amp;&amp; rdown) { inits[nowx][nowy + 1]= 'H', inits[nowx][nowy + 2]= 'H', inits[nowx + 1][nowy]= 'H', inits[nowx + 1][nowy + 1]= 'H'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx][nowy + 2]= '.', inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy + 1]= '.'; } // H2 if(right &amp;&amp; down &amp;&amp; rdown &amp;&amp; rddown) { inits[nowx][nowy + 1]= 'H', inits[nowx + 1][nowy]= 'H', inits[nowx + 1][nowy + 1]= 'H', inits[nowx + 2][nowy + 1]= 'H'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy + 1]= '.', inits[nowx + 2][nowy + 1]= '.'; } // H3 if(right &amp;&amp; down &amp;&amp; rdown &amp;&amp; dleft) { inits[nowx][nowy + 1]= 'H', inits[nowx + 1][nowy]= 'H', inits[nowx + 1][nowy + 1]= 'H', inits[nowx + 1][nowy - 1]= 'H'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy + 1]= '.', inits[nowx + 1][nowy - 1]= '.'; } // H4 if(down &amp;&amp; rdown &amp;&amp; ddown &amp;&amp; rddown) { inits[nowx + 1][nowy]= 'H', inits[nowx + 1][nowy + 1]= 'H', inits[nowx + 2][nowy]= 'H', inits[nowx + 2][nowy + 1]= 'H'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy + 1]= '.', inits[nowx + 2][nowy]= '.', inits[nowx + 2][nowy + 1]= '.'; } // H5 if(right &amp;&amp; down &amp;&amp; rdown &amp;&amp; drright) { inits[nowx][nowy + 1]= 'H', inits[nowx + 1][nowy]= 'H', inits[nowx + 1][nowy + 1]= 'H', inits[nowx + 1][nowy + 2]= 'H'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy + 1]= '.', inits[nowx + 1][nowy + 2]= '.'; } // H6 if(down &amp;&amp; ddown &amp;&amp; dleft &amp;&amp; ddleft) { inits[nowx + 1][nowy]= 'H', inits[nowx + 2][nowy]= 'H', inits[nowx + 1][nowy - 1]= 'H', inits[nowx + 2][nowy - 1]= 'H'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 2][nowy]= '.', inits[nowx + 1][nowy - 1]= '.', inits[nowx + 2][nowy - 1]= '.'; } // H7 if(right &amp;&amp; rright &amp;&amp; rdown &amp;&amp; drright) { inits[nowx][nowy + 1]= 'H', inits[nowx][nowy + 2]= 'H', inits[nowx + 1][nowy + 1]= 'H', inits[nowx + 1][nowy + 2]= 'H'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx][nowy + 2]= '.', inits[nowx + 1][nowy + 1]= '.', inits[nowx + 1][nowy + 2]= '.'; } // H8 if(right &amp;&amp; down &amp;&amp; ddown &amp;&amp; rdown) { inits[nowx][nowy + 1]= 'H', inits[nowx + 1][nowy]= 'H', inits[nowx + 2][nowy]= 'H', inits[nowx + 1][nowy + 1]= 'H'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx + 1][nowy]= '.', inits[nowx + 2][nowy]= '.', inits[nowx + 1][nowy + 1]= '.'; } chose['H']= false; } int rrdright= (getlimit(nowx + 1, nowy + 3) &amp;&amp; inits[nowx + 1][nowy + 3] == '.'); int ddldown= (getlimit(nowx + 3, nowy - 1) &amp;&amp; inits[nowx + 3][nowy - 1] == '.'); int drddown= (getlimit(nowx + 3, nowy + 1) &amp;&amp; inits[nowx + 3][nowy + 1] == '.'); if(!chose['I']) { chose['I']= true, inits[nowx][nowy]= 'I'; // I1 if(right &amp;&amp; rright &amp;&amp; drright &amp;&amp; rrdright) { inits[nowx][nowy + 1]= 'I', inits[nowx][nowy + 2]= 'I', inits[nowx + 1][nowy + 2]= 'I', inits[nowx + 1][nowy + 3]= 'I'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx][nowy + 2]= '.', inits[nowx + 1][nowy + 2]= '.', inits[nowx + 1][nowy + 3]= '.'; } // I2 if(down &amp;&amp; ddown &amp;&amp; ddleft &amp;&amp; ddldown) { inits[nowx + 1][nowy]= 'I', inits[nowx + 2][nowy]= 'I', inits[nowx + 2][nowy - 1]= 'I', inits[nowx + 3][nowy - 1]= 'I'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 2][nowy]= '.', inits[nowx + 2][nowy - 1]= '.', inits[nowx + 3][nowy - 1]= '.'; } // I3 if(right &amp;&amp; rdown &amp;&amp; drright &amp;&amp; rrdright) { inits[nowx][nowy + 1]= 'I', inits[nowx + 1][nowy + 1]= 'I', inits[nowx + 1][nowy + 2]= 'I', inits[nowx + 1][nowy + 3]= 'I'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx + 1][nowy + 1]= '.', inits[nowx + 1][nowy + 2]= '.', inits[nowx + 1][nowy + 3]= '.'; } // I4 if(down &amp;&amp; dleft &amp;&amp; ddleft &amp;&amp; ddldown) { inits[nowx + 1][nowy]= 'I', inits[nowx + 1][nowy - 1]= 'I', inits[nowx + 2][nowy - 1]= 'I', inits[nowx + 3][nowy - 1]= 'I'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy - 1]= '.', inits[nowx + 2][nowy - 1]= '.', inits[nowx + 3][nowy - 1]= '.'; } // I5 if(right &amp;&amp; down &amp;&amp; dleft &amp;&amp; dlleft) { inits[nowx][nowy + 1]= 'I', inits[nowx + 1][nowy]= 'I', inits[nowx + 1][nowy - 1]= 'I', inits[nowx + 1][nowy - 2]= 'I'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy - 1]= '.', inits[nowx + 1][nowy - 2]= '.'; } // I6 if(down &amp;&amp; rdown &amp;&amp; rddown &amp;&amp; drddown) { inits[nowx + 1][nowy]= 'I', inits[nowx + 1][nowy + 1]= 'I', inits[nowx + 2][nowy + 1]= 'I', inits[nowx + 3][nowy + 1]= 'I'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy + 1]= '.', inits[nowx + 2][nowy + 1]= '.', inits[nowx + 3][nowy + 1]= '.'; } // I7 if(right &amp;&amp; rright &amp;&amp; down &amp;&amp; dleft) { inits[nowx][nowy + 1]= 'I', inits[nowx][nowy + 2]= 'I', inits[nowx + 1][nowy]= 'I', inits[nowx + 1][nowy - 1]= 'I'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx][nowy + 2]= '.', inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy - 1]= '.'; } // I8 if(down &amp;&amp; ddown &amp;&amp; rddown &amp;&amp; drddown) { inits[nowx + 1][nowy]= 'I', inits[nowx + 2][nowy]= 'I', inits[nowx + 2][nowy + 1]= 'I', inits[nowx + 3][nowy + 1]= 'I'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 2][nowy]= '.', inits[nowx + 2][nowy + 1]= '.', inits[nowx + 3][nowy + 1]= '.'; } chose['I']= false; } if(!chose['J']) { chose['J']= true, inits[nowx][nowy]= 'J'; // J1 if(down &amp;&amp; dleft &amp;&amp; rdown &amp;&amp; ddown) { inits[nowx + 1][nowy]= 'J', inits[nowx + 1][nowy - 1]= 'J', inits[nowx + 1][nowy + 1]= 'J', inits[nowx + 2][nowy]= 'J'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy - 1]= '.', inits[nowx + 1][nowy + 1]= '.', inits[nowx + 2][nowy]= '.'; } chose['J']= false; } if(!chose['K']) { chose['K']= true, inits[nowx][nowy]= 'K'; // K1 if(down &amp;&amp; rdown &amp;&amp; rddown &amp;&amp; ddrright) { inits[nowx + 1][nowy]= 'K', inits[nowx + 1][nowy + 1]= 'K', inits[nowx + 2][nowy + 1]= 'K', inits[nowx + 2][nowy + 2]= 'K'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy + 1]= '.', inits[nowx + 2][nowy + 1]= '.', inits[nowx + 2][nowy + 2]= '.'; } // K2 if(right &amp;&amp; down &amp;&amp; dleft &amp;&amp; ddleft) { inits[nowx][nowy + 1]= 'K', inits[nowx + 1][nowy]= 'K', inits[nowx + 1][nowy - 1]= 'K', inits[nowx + 2][nowy - 1]= 'K'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy - 1]= '.', inits[nowx + 2][nowy - 1]= '.'; } // K3 if(right &amp;&amp; rdown &amp;&amp; drright &amp;&amp; ddrright) { inits[nowx][nowy + 1]= 'K', inits[nowx + 1][nowy + 1]= 'K', inits[nowx + 1][nowy + 2]= 'K', inits[nowx + 2][nowy + 2]= 'K'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx + 1][nowy + 1]= '.', inits[nowx + 1][nowy + 2]= '.', inits[nowx + 2][nowy + 2]= '.'; } // K4 if(down &amp;&amp; dleft &amp;&amp; ddleft &amp;&amp; ddlleft) { inits[nowx + 1][nowy]= 'K', inits[nowx + 1][nowy - 1]= 'K', inits[nowx + 2][nowy - 1]= 'K', inits[nowx + 2][nowy - 2]= 'K'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy - 1]= '.', inits[nowx + 2][nowy - 1]= '.', inits[nowx + 2][nowy - 2]= '.'; } chose['K']= false; } int dllleft= (getlimit(nowx + 1, nowy - 3) &amp;&amp; inits[nowx + 1][nowy - 3] == '.'); if(!chose['L']) { chose['L']= true, inits[nowx][nowy]= 'L'; // L1 if(right &amp;&amp; rright &amp;&amp; rrright &amp;&amp; down) { inits[nowx][nowy + 1]= 'L', inits[nowx][nowy + 2]= 'L', inits[nowx][nowy + 3]= 'L', inits[nowx + 1][nowy]= 'L'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx][nowy + 2]= '.', inits[nowx][nowy + 3]= '.', inits[nowx + 1][nowy]= '.'; } // L2 if(right &amp;&amp; rdown &amp;&amp; rddown &amp;&amp; drddown) { inits[nowx][nowy + 1]= 'L', inits[nowx + 1][nowy + 1]= 'L', inits[nowx + 2][nowy + 1]= 'L', inits[nowx + 3][nowy + 1]= 'L'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx + 1][nowy + 1]= '.', inits[nowx + 2][nowy + 1]= '.', inits[nowx + 3][nowy + 1]= '.'; } // L3 if(down &amp;&amp; dleft &amp;&amp; dlleft &amp;&amp; dllleft) { inits[nowx + 1][nowy]= 'L', inits[nowx + 1][nowy - 1]= 'L', inits[nowx + 1][nowy - 2]= 'L', inits[nowx + 1][nowy - 3]= 'L'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy - 1]= '.', inits[nowx + 1][nowy - 2]= '.', inits[nowx + 1][nowy - 3]= '.'; } // L4 if(down &amp;&amp; ddown &amp;&amp; dddown &amp;&amp; drddown) { inits[nowx + 1][nowy]= 'L', inits[nowx + 2][nowy]= 'L', inits[nowx + 3][nowy]= 'L', inits[nowx + 3][nowy + 1]= 'L'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 2][nowy]= '.', inits[nowx + 3][nowy]= '.', inits[nowx + 3][nowy + 1]= '.'; } // L5 if(down &amp;&amp; rdown &amp;&amp; drright &amp;&amp; rrdright) { inits[nowx + 1][nowy]= 'L', inits[nowx + 1][nowy + 1]= 'L', inits[nowx + 1][nowy + 2]= 'L', inits[nowx + 1][nowy + 3]= 'L'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 1][nowy + 1]= '.', inits[nowx + 1][nowy + 2]= '.', inits[nowx + 1][nowy + 3]= '.'; } // L6 if(down &amp;&amp; ddown &amp;&amp; dddown &amp;&amp; ddldown) { inits[nowx + 1][nowy]= 'L', inits[nowx + 2][nowy]= 'L', inits[nowx + 3][nowy]= 'L', inits[nowx + 3][nowy - 1]= 'L'; if(dfs(nowx, nowy + 1)) return true; inits[nowx + 1][nowy]= '.', inits[nowx + 2][nowy]= '.', inits[nowx + 3][nowy]= '.', inits[nowx + 3][nowy - 1]= '.'; } // L7 if(right &amp;&amp; rright &amp;&amp; rrright &amp;&amp; rrdright) { inits[nowx][nowy + 1]= 'L', inits[nowx][nowy + 2]= 'L', inits[nowx][nowy + 3]= 'L', inits[nowx + 1][nowy + 3]= 'L'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx][nowy + 2]= '.', inits[nowx][nowy + 3]= '.', inits[nowx + 1][nowy + 3]= '.'; } // L8 if(right &amp;&amp; down &amp;&amp; ddown &amp;&amp; dddown) { inits[nowx][nowy + 1]= 'L', inits[nowx + 1][nowy]= 'L', inits[nowx + 2][nowy]= 'L', inits[nowx + 3][nowy]= 'L'; if(dfs(nowx, nowy + 1)) return true; inits[nowx][nowy + 1]= '.', inits[nowx + 1][nowy]= '.', inits[nowx + 2][nowy]= '.', inits[nowx + 3][nowy]= '.'; } chose['L']= false; } inits[nowx][nowy]= '.'; return false;}int main() { for(int i= 1; i &lt; 11; i++) { for(int j= 1; j &lt;= i; j++) { cin &gt;&gt; inits[i][j]; if(inits[i][j] != '.') chose[(int)inits[i][j]]= 1; } } if(dfs(1, 1)) { for(int i= 1; i &lt; 11; i++) { for(int j= 1; j &lt;= i; j++) putchar(inits[i][j]); putchar('\\n'); } } else printf(\"No solution\\n\"); return 0;}","link":"/2019-03/17-luogu4205/"},{"title":"LuoguP5145 - 漂浮的鸭子","text":"【LuoguP5145】漂浮的鸭子题目链接: https://www.luogu.org/problemnew/show/P5145 前言最近颓的东西太多了, 终于又来做搜索题. 这题很水 随手交了个暴力随机化就A了. 分析这道题正解思路非常妙, 代码比较短. 但我们能不能想一个更简单粗暴的方法呢? 先交一下能被卡成接近 $ O(n^2) $ 的暴力, 对于每一个点跑一遍DFS, 如果能回到此点就更新答案, 再加一个玄学剪枝, 将这个环上所有点打标记, 这些点就不用再DFS了. 开O2只有50分 1234567891011121314151617181920212223242526// luogu-judger-enable-o2#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;int n, tox[100001], toy[100001], rex[100001], tmpx, ans, walkpast[100001], lw[100001];void dfs(int nown) { memcpy(walkpast, lw, sizeof(walkpast)); int sum= 0, to= nown; while(!walkpast[to]) { walkpast[to]= 1; sum+= toy[to], to= tox[to]; } if(to != nown) return; memcpy(lw, walkpast, sizeof(walkpast)); ans= max(ans, sum); return;}int main() { cin &gt;&gt; n; for(int i= 1; i &lt;= n; i++) cin &gt;&gt; tox[i] &gt;&gt; toy[i], rex[tox[i]]= i; for(int i= 1; i &lt;= n; i++) if(!walkpast[i]) dfs(i); cout &lt;&lt; ans &lt;&lt; endl; return 0;} 考虑优化, 其实复杂度是可以玄学过去的 先把cin换成scnaf. 然后我加了判断有环, 但此点不在环上的一个小剪枝. 1234if(to != nown) { lw[nown]= 1; return;} 通俗一点讲, 让以后到达这个点的鸭子都知道自己的水坑不在环里就不用继续搜了. 要是还T怎么办, 那改一下搜索顺序说不定就A了, 为了防止从 N 到 1 一条链卡暴力的情况, 我选择随机起点, 再加一个卡时限. 代码1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;using namespace std;int n, tox[100001], toy[100001], rex[100001], tmpx, ans, walkpast[100001], lw[100001];void dfs(int nown) { memcpy(walkpast, lw, sizeof(walkpast)); int sum= 0, to= nown; while(!walkpast[to]) { walkpast[to]= 1; sum+= toy[to], to= tox[to]; } if(to != nown) { lw[nown]= 1; return; } memcpy(lw, walkpast, sizeof(walkpast)); ans= max(ans, sum); return;}int main() { scanf(\"%d\", &amp;n); for(int i= 1; i &lt;= n; i++) scanf(\"%d%d\", tox + i, toy + i), rex[tox[i]]= i; while(clock() &lt; CLOCKS_PER_SEC * 0.9) { int tmpx= rand() % n + 1; if(!walkpast[tmpx]) dfs(tmpx); } printf(\"%d\\n\", ans); return 0;}","link":"/2019-05/22-luogu5145/"},{"title":"LuoguP5440 - 【XR-2】奇迹","text":"【LuoguP5440】【XR-2】奇迹题目链接: https://www.luogu.org/problemnew/show/P5440 前言 不要学那些很酷很炫的算法，不要看不起那些基础算法，比如说搜索。 然后我就天天做搜索，最后退役。 分析正解搜索或暴力枚举，代码区已经几乎是相同的思路，只是有些大佬有很多优化，效率快，但是特批有很多并且极其复杂。经对比我觉得我的代码可视性还是不错的，并且没有乱七八糟的特判，可以说是常规DFS代码+筛质数优化的代码。 下面说一下思路。首先题目很好理解，一个有效日期，日、月+日、年+月+日组成的数字均为质数，那就先不考虑优化，直接上模拟。 按DFS的常规模板（自己总结出来的），先有一个参数，代表搜索到哪一位。在本题中就是日期的第几位数字，我选择的顺序为：日-&gt;月-&gt;年，这样可以逐层判断，而且效率较高代码优雅。 第二个参数，是为了方便和小幅提升效率，我们把已经枚举完的位编成一个整数$ x $，然后日就是 x % 100 ，月就是 x % 10000 / 100 ，年就是x / 10000。 这道题中还需要考虑到特殊情况，是否必须为闰年或大月。我为了方便，当成两个参数来传递，现在想想好像可以改一个。因为一个只考虑年份，一个只考虑月份。DFS带详细注释代码如下，自己觉得算得上优雅。1234567891011121314151617181920212223242526272829303132333435363738// 调用方法: dfs(8, 0, 0, 0)int dfs(int nown, int num, int rn, int jy) { if(nown == 0) { // 日期全部枚举完 if(num / 10000 == 0) return 0; // 非常关键，0不能当年份（我一开始没加就得10分） if(rn &amp;&amp; pdrn(num / 10000) == 0) return 0; // 如果必须为闰年就判断年份 return pdzs(num); // 总日期还得为质数 } if(nown == 6) { // 枚举完日 if(num == 0 || num &gt; 31 || !pdzs(num)) return 0; // 如果是等于0日、31日以上或不是质数就return if(num == 31) jy= 1; // 如果是31日就必须为大月 } if(nown == 4) { // 判断完日、月 if(num &lt; 32 || num &gt; 1231 || !pdzs(num)) return 0; // 如果是等于0月、13月以上或不是质数就return if(jy &amp;&amp; !yue[num / 100]) return 0; // 如果必须为大月就判断月份num / 100，yue数组代表是否为大月 if(num / 100 == 2) { if(num % 100 &gt; 29) return 0; // 2月最多29天 if(num % 100 == 29) rn= 1; // 如果是2月29日就必须为闰年 } } if(a[nown] != -1) return dfs(nown - 1, a[nown] * p10[8 - nown] + num, rn, jy); // 如果输入给出就直接进入下一层，p10数组相当于pow10 int res= 0; for(int i= 0; i &lt;= 9; i++) res+= dfs(nown - 1, i * p10[8 - nown] + num, rn, jy); // 枚举0~9为此位 return res;} 如果是用复杂度为$ O(\\sqrt{n}) $ 的判断质数就只有90分，所以还得用线性筛预处理出$ \\sqrt{100000000} = 10000 $ 以内的质数，然后我们判断质数就对这些数取模就行了，具体原理不再解释。 1234567891011121314151617181920// 筛10005以内的质数inline void init() { flag[1]= 1; for(int i= 2; i &lt; 10005; i++) { if(!flag[i]) prim[++tot]= i; for(int j= 1; j &lt;= tot; j++) { if(i * prim[j] &gt;= 10005) break; flag[i * prim[j]]= 1; if(i % prim[j] == 0) break; } } return;}// 判断质数inline int pdzs(int x) { if(x &lt; 2) return 0; for(int i= 1; i &lt;= tot; i++) if(x % prim[i] == 0) return x == prim[i]; return 1;} 然后就可以愉快的AC了，总代码只有70行且简单优雅。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;using namespace std;int n, a[9], prim[10005], flag[10005], tot;char tmpc;int p10[]= {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000};int yue[]= {0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1};inline void init() { flag[1]= 1; for(int i= 2; i &lt; 10005; i++) { if(!flag[i]) prim[++tot]= i; for(int j= 1; j &lt;= tot; j++) { if(i * prim[j] &gt;= 10005) break; flag[i * prim[j]]= 1; if(i % prim[j] == 0) break; } } return;}inline int pdrn(int x) { return (x % 4 == 0 &amp;&amp; x % 100 != 0) || (x % 400 == 0 &amp;&amp; x % 3200 != 0);}inline int pdzs(int x) { if(x &lt; 2) return 0; for(int i= 1; i &lt;= tot; i++) if(x % prim[i] == 0) return x == prim[i]; return 1;}int dfs(int nown, int num, int rn, int jy) { if(nown == 0) { if(num / 10000 == 0) return 0; if(rn &amp;&amp; pdrn(num / 10000) == 0) return 0; return pdzs(num); } if(nown == 6) { if(num == 0 || num &gt; 31 || !pdzs(num)) return 0; if(num == 31) jy= 1; } if(nown == 4) { if(num &lt; 32 || num &gt; 1231 || !pdzs(num)) return 0; if(jy &amp;&amp; !yue[num / 100]) return 0; if(num / 100 == 2) { if(num % 100 &gt; 29) return 0; if(num % 100 == 29) rn= 1; } } if(a[nown] != -1) return dfs(nown - 1, a[nown] * p10[8 - nown] + num, rn, jy); int res= 0; for(int i= 0; i &lt;= 9; i++) res+= dfs(nown - 1, i * p10[8 - nown] + num, rn, jy); return res;}char get() { char ch= getchar(); while((ch &lt; '0' || ch &gt; '9') &amp;&amp; ch != '-') ch= getchar(); return ch;}void put(int x) { if(x &gt; 9) put(x / 10); putchar('0' + x % 10); return;}int main() { init(), cin &gt;&gt; n; while(n--) { for(int i= 1; i &lt;= 8; i++) tmpc= get(), a[i]= (tmpc == '-' ? -1 : tmpc - '0'); put(dfs(8, 0, 0, 0)), putchar('\\n'); } return 0;}","link":"/2019-07/15-luogu5440/"},{"title":"AT2657 - Mole and Abandoned Mine","text":"【AT2657】【LuoguAT2657】Mole and Abandoned Mine题目链接1: https://www.luogu.org/problemnew/show/AT2657题目链接2: https://www.luogu.org/jump/atcoder/2657 引言时隔一月, 我又回来了写题解了. 以后可能颓的时间会变少. 现在文化课好像更重要些, 还是要专心学习吧. 本题是一个状压练手好题. 分析我再大致翻译描述一下题目, 我一开始因为没看样例就理解错了. 本题给出N点M边的无向图, 然后要割掉其中一些边, 使从1到N只有一条不经过重复顶点的边, 求删掉的边的边权和最小. 重点是这条路径不需要经过所有点 看数据范围, 只可能是状压或者暴力搜索, 然而难度说明只能是状压了. 很容易想到, 求删边边权最少, 相当于求留下边的边权和最大. 然而我没有想到具体怎么求, 搜到了一个大佬的题解, 最终的图还有一个重要性质: 每个点最多只与保留下来的那条路径上的一个点有边相连 所以我们先预处理出所有的联通块中的边权和. 然后进行DP, 二维数组, 第一维为处理了哪些点, 第二维为到达哪个点(当前终点). 有两种转移, 一种是新处理一个点, 一种是将一个联通块与当前终点相连. 我从这道题还学习了一个新的二进制性质.枚举一个数二进制下的所有子集: 1234int num = 59; // 某个数for(int i= num; i; i= (i - 1) &amp; num) { // i 为 num 的一个二进制子集} 比如（0101）的子集为（0101）,（0100）,（0001）,（0000）. 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;int n, m, nn, edge[16][16], tmpx, tmpy, tmpz, sums;int blocks[1 &lt;&lt; 16], len, f[1 &lt;&lt; 16][16];int main() { cin &gt;&gt; n &gt;&gt; m; nn= 1 &lt;&lt; n; for(int i= 1; i &lt;= m; i++) { cin &gt;&gt; tmpx &gt;&gt; tmpy &gt;&gt; tmpz; sums+= edge[tmpx][tmpy]= edge[tmpy][tmpx]= tmpz; } for(int i= 0; i &lt; nn; i++) { for(int j= 1; j &lt;= n; j++) { if(!(i &amp; (1 &lt;&lt; (j - 1))) &amp;&amp; !(blocks[i | (1 &lt;&lt; (j - 1))])) { blocks[i | (1 &lt;&lt; (j - 1))]= blocks[i]; for(int k= 1; k &lt;= n; k++) if((i &amp; (1 &lt;&lt; (k - 1)))) blocks[i | (1 &lt;&lt; (j - 1))]+= edge[j][k]; } } } memset(f, -1, sizeof(f)); f[1][1]= 0; for(int i= 0; i &lt; nn; i++) { for(int j= 1; j &lt;= n; j++) { if(f[i][j] != -1 &amp;&amp; (i &amp; (1 &lt;&lt; (j - 1)))) { for(int k= 1; k &lt;= n; k++) if(!(i &amp; (1 &lt;&lt; (k - 1))) &amp;&amp; edge[j][k]) f[i | (1 &lt;&lt; (k - 1))][k]= max(f[i | (1 &lt;&lt; (k - 1))][k], f[i][j] + edge[j][k]); tmpx= ((nn - 1) ^ i) | (1 &lt;&lt; (j - 1)); for(int k= tmpx; k; k= (k - 1) &amp; tmpx) if(k &amp; (1 &lt;&lt; (j - 1))) f[i | k][j]= max(f[i | k][j], f[i][j] + blocks[k]); } } } cout &lt;&lt; sums - f[nn - 1][n] &lt;&lt; endl; return 0;}","link":"/2019-04/22-luoguat2657/"},{"title":"技巧 - 写一个应用于Luogu的油猴插件","text":"写一个应用于Luogu的油猴插件，拥有在任意页面上快捷搜索跳转题目的功能。 安装链接（插件发布地址）: https://greasyfork.org/zh-CN/scripts/389291-luogu-quick-searcher 前言应同机房大佬要求，做一个洛谷快捷题目搜索的油猴插件。 一些鲜为人知的历史其实这个早在洛谷??.9版本（大概是18年底的一次UI更新）就写过一次了。 那段时间luogu把搜索框去掉了，以致于不能方便的搜索题目，才写了这个插件，并且使用luogu很早前搜索框的css。 过了半个月洛谷又更新了，然后右上角个人头像旁边多了搜索框。我当时直接退坑了，后来没多长时间插件就无法使用了。 为什么要重构插件然后我发现洛谷新的搜索框非常不贴近人意（小声），然后同机房大佬又一次要求。 趁着没东西颓废一晚上颓了出来，恰好半年时间，我的JS、HTML能力已经大幅提高，所以这个插件做起来相当简单。 那现在和半年前有什么区别首先洛谷把半年前已经废了的CSS都删了（包括半年前的搜索框CSS）。 并且洛谷的页面也有很大变化。误人子弟的说一句，好像洛谷现在是二次加载动态渲染？然后不用jQuery了？ 然后是个人原因，现在的我有一定JS写代码能力，对一些基础语法比较熟练，熟悉很多方法。之前傻傻分不清jQuery和Web API的函数，只能一次一次测试来运用（哪个能用就用哪个）。 正题可以先进入文章开头的链接查看介绍，也可以查看全部代码。 首先我们设定 F1 打开搜索框，若已打开就关闭，F1键码为112。注册按键： 1document.onkeydown = function (event) { if (event.keyCode == 112) mainfunc(); }; mainfunc 函数就是用来打开关闭对话框。但是这个页面本来没有对话框，该怎么打开呢？ 那么就需要新建，新建需要在网页中插入HTML。根据经验，我们需要在页面加载完成之后才能插入HTML，否则有不可预料的BUG。判断网页是否加载完成： 12345if (document.readyState == \"complete\") { /* Write your code here. */} 然后就是新建元素、改样式、插入到网页中，这些很语法基础就直接给出，相关函数请自行了解。 我们选择把元素加入到页面的app（洛谷设计的）中。初始化： 1234567891011var newElement = document.createElement(\"div\");newElement.id = \"CiyangSearch\";newElement.innerHTML = \"&lt;input type = 'text'&gt; | &lt;a&gt;&lt;i class = 'fas fa-search'&gt;&lt;/i&gt;&lt;/a&gt; | &lt;a&gt;&lt;i class= 'fa fa-cog'&gt;&lt;/i&gt;&lt;/a&gt;\";newElement.style.position = \"fixed\";newElement.style.zIndex = \"2\";newElement.style.top = \"10%\";newElement.style.left = \"30%\";newElement.style.width = \"240px\";newElement.style.backgroundColor = \"rgb(128,128,128)\";var appElement = document.getElementById('app');appElement.appendChild(newElement); 上面的代码就已经可以打开一个搜索框，还有搜索按钮和设置按钮，但非常丑陋。 只有搜索框但是不能进行搜索，所以要绑定点击搜索按钮和回车键，回车键的键码为13。注册函数： 12345678910111213141516newElement.children[0].onkeydown = function (event) { if (event.keyCode == 13) { var str = this.value; /* Write your code here. */ } return;};newElement.children[1].onclick = function () { var str = newElement.children[0].value; /* Write your code here. */ return;}; str就是搜索框中输入的内容，获取后就可以跳转题目了。 我们想让它可自动识别是否为题目，如果是就打开题目页面，否则就打开题目列表进行搜索。 比如：输入P1001打开P1001题目页面，输入1001就进入题目列表搜索1001。 因为OI不学正则表达式，所以一般情况下我们想到if判断。这非常麻烦，会使代码复杂冗长，这个时候正则表达式就能大显身手了。 此处借鉴了另一个油猴插件Luogu Problem Jumper的匹配代码，应该是匹配洛谷题目最好的代码。 12345678910function judegeProblem(str) { if (str.match(/AT[0-9]{1,4}/) == str) return true; if (str.match(/CF[0-9]{1,4}[A-Z][0-9]{0,1}/) == str) return true; if (str.match(/SP[0-9]{1,5}/) == str) return true; if (str.match(/P[0-9]{4}/) == str) return true; if (str.match(/UVA[0-9]{1,5}/) == str) return true; if (str.match(/U[0-9]{1,6}/) == str) return true; if (str.match(/T[0-9]{1,6}/) == str) return true; return false;} 接下来是打开页面，有两种方式，前者是从当前页跳转，后者是新标签页打开。 12window.location = url;window.open(url); 我们想要设计为用户选择首选方式，可首选其中一种方式，搜索时先输入 # 才能用优先级低的方式。 1234567891011121314151617var dUrl = 1;/*A lot of code.*/function judgeURL(way, str) { if (str.length == 0) return; if (judegeProblem(str)) go(dUrl ^ way, '/problemnew/show/' + str); else go(dUrl ^ way, '/problem/list?keyword=' + str); return;}function go(k, url) { if (k == 0) window.location = url; else window.open(url); removek();} dUrl设为1就是首选新标签页，way表示是否先输入了 # 。 再回到绑定按键、点击搜索按钮的地方，比较懒所以代码没有合并到一起： 12345678910111213141516newElement.children[0].onkeydown = function (event) { if (event.keyCode == 13) { var str = this.value; if (str.length == 0) return; if (str[0] == '#') judgeURL(1, str.substring(1, str.length)); else judgeURL(0, str); } return;};newElement.children[1].onclick = function () { var str = newElement.children[0].value; if (str.length == 0) return; if (str[0] == '#') judgeURL(1, str.substring(1, str.length)); else judgeURL(0, str); return;}; 主体基本完成，然后就是一些小功能。若打开搜索框，再次按下 F1 关闭。使设置打开页面方式更加可视化，完善设置按钮。 在 mainfuc 函数中，先加入一行代码： 1if (removek()) return; 之前我们为了方便，将搜索框整体的元素ID改为了CiyangSearch，可以直接根据此ID来获取控件。代码简单： 12345678function removek() { var search = document.getElementById(\"CiyangSearch\"); if (search) { search.parentNode.removeChild(search); return true; } return false;} 完善设置按钮也很简单，首先在 mainfunc 绑定按键、搜索按钮处理下加入一行代码： 1newElement.children[2].onclick = function () { setLink(); }; 先介绍两个油猴自带的函数，GM_setValue和GM_getValue，可以非常方便的存储和读取数据，具体原理可以自行搜索。 点击设置按钮后跳出对话框，用户输入1或者0，设置首选方式。将之前的dUrl设置为读取数据。 1234567891011var dUrl = GM_getValue(\"default_way\");function setLink() { var defaultWay = prompt(\"请输入首选打开网页方式，1 为新标签页，0为从当前页跳转。当前为\" + dUrl + \"，搜索先输入 # 可使用优先级低的方式。\"); if (defaultWay == null) return; if (defaultWay != \"0\" &amp;&amp; defaultWay != \"1\") { alert(\"您的输入有误\"); return; } GM_setValue(\"default_way\", defaultWay); location.reload();} 我们还有需要一个使搜索的输入框自动获得焦点的小特性，只要在元素（控件）插入页面后加入一行代码： 1newElement.children[0].focus(); 然后8.23美化了一下UI，具体就不给出了。增加了设置背景颜色，换汤不换药。其中较为重要的修改： 123456789101112var dUrl = GM_getValue(\"default_way\"), bgColor = GM_getValue(\"searcher_bg\");if (bgColor == undefined) { GM_setValue(\"searcher_bg\", \"rgba(135,206,235,0.5)\"); bgColor = \"rgba(135,206,235,0.5)\";}newElement.innerHTML = \"&lt;input type = 'text'&gt; | &lt;i class = 'fas fa-search'&gt;&lt;/i&gt; | &lt;i class= 'fas fa-cog'&gt;&lt;/i&gt; | &lt;i class ='fas fa-crosshairs'&gt;&lt;/i&gt; |\";function setBGColor() { var searcherBG = prompt(\"请输入背景颜色码，支持RGB和十六进制。当前为\" + bgColor + \"。\", bgColor); if (searcherBG == null) return; GM_setValue(\"searcher_bg\", searcherBG); location.reload();} 分别处于代码各个位置，思路与设置打开方式类似，自行了解即可。 后记还有什么问题可以在博客或发布网站评论提出，也可以用社交软件联系我。 在greasyfork发布，链接：https://greasyfork.org/zh-CN/scripts/389291-luogu-quick-searcher 如果时间充足还会一直更新，有要求也可以提出。","link":"/2019-08/22-luogusearcher/"},{"title":"UVA751 - Triangle War","text":"【UVA751】Triangle War题目链接1: https://www.luogu.com.cn/problem/UVA751题目链接2: https://www.luogu.com.cn/jump/uva/751 前言最近看R在玩某树来做黑白棋AI，让我也想学习博弈相关内容。然后学了max-min策略，然后又学了alpha-beta剪枝。 这个题是练习max-min策略+alpha-beta剪枝的好题，但是我们也可以记忆化搜索。 并且此题状态少，记忆化只需要20ms，比用alpha-beta剪枝的做法要快一些。 分析当然我做这道题还是想学习alpha-beta剪枝的，使用此算法的题解已有，所以不多加解释。 此题有两种max-min策略的解法，解法1是最大最小化最终胜负（1为先手胜利，-1为后手胜利），解法2是最大最小化最终得分差（先手得分-后手得分），当然流程就是先手最大化此值，后手最小化此值。 至于局面的存储，与已有题解类似，存储边的编号，然后用二进制表示已连接的边。而三角形连接我们就手写一个数组表示需要哪三条边（很麻烦）。这个题只有单位三角形得分，似乎题意里没说。 再来说两种解法的差异，因为最终胜负在一方大于等于5分就可判定，所以解法1效率较高，并且我们还可用使用alpha-beta剪枝来优化。 当然我们也可以用解法2。有一个显然的结论，无论此步是A还是B，一个状态只会对应一个最优得分。那么就可以使用记忆化，已知状态总共有$(1 &lt;&lt; 18) - 1$种，这样效率就高了。并且我们每组数据前不需要清空记忆化数组，因为一个状态对应一个分数，并不需要知道你是如何到达此状态的。 实现时先模拟给出的N步，然后记录双方已得分数。然后max_min搜索，如果此步得分，继续操作，如果此步不得分，就让对手操作，然后减去对手操作的分数，如果全部连接就返回0，每层都是最大化自己的得分。至于为什么双方都是最大化，我给出以下解释：A最大化(A的得分-B的得分)，B最大化(B的得分-A的得分)，所以都是最大化。 在最终判定胜负时，设当前玩家为p(p为0或1)，若p已得分数+max_min(从p开始)的结果&gt;(p^1)的分数就判定p胜利，否则(p^1)胜利。 代码解法1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int edg[11][11];int tri[] = {(1 &lt;&lt; 0) + (1 &lt;&lt; 1) + (1 &lt;&lt; 2), (1 &lt;&lt; 3) + (1 &lt;&lt; 4) + (1 &lt;&lt; 7), (1 &lt;&lt; 2) + (1 &lt;&lt; 4) + (1 &lt;&lt; 5), (1 &lt;&lt; 5) + (1 &lt;&lt; 6) + (1 &lt;&lt; 10), (1 &lt;&lt; 8) + (1 &lt;&lt; 9) + (1 &lt;&lt; 15), (1 &lt;&lt; 7) + (1 &lt;&lt; 9) + (1 &lt;&lt; 11), (1 &lt;&lt; 11) + (1 &lt;&lt; 12) + (1 &lt;&lt; 16), (1 &lt;&lt; 10) + (1 &lt;&lt; 12) + (1 &lt;&lt; 13), (1 &lt;&lt; 13) + (1 &lt;&lt; 14) + (1 &lt;&lt; 17)};#define addedge(x, y, z) (edg[x][y] = edg[y][x] = z)void init() { addedge(1, 2, 0); addedge(1, 3, 1); addedge(2, 3, 2); // ... // 本连边方式不推荐学习，因此部分内容已省略，相信有更好的方式 return;}int T, n, tmpx, tmpy;int nextStep(int lst, int nst) { int cnt = 0; // lst 为之前状态 nst 为当前状态 for(int i = 0; i &lt; 9; i++) if((lst &amp; tri[i]) != tri[i] &amp;&amp; (nst &amp; tri[i]) == tri[i]) ++cnt; return cnt;}const int full = (1 &lt;&lt; 18) - 1;int alpha_beta(int nowp, int st, int alpha, int beta, int ans[2]) { if(ans[0] &gt;= 5) return 1; if(ans[1] &gt;= 5) return -1; int fst = full ^ st, nst; while(fst) { int edge = fst &amp; (-fst); // 枚举连边 int res = nextStep(st, (nst = st | edge)); if(res) { ans[nowp] += res; (nowp ? beta : alpha) = (nowp ? min&lt; int &gt; : max&lt; int &gt;)((nowp ? beta : alpha), alpha_beta(nowp, nst, alpha, beta, ans)); ans[nowp] -= res; } else { (nowp ? beta : alpha) = (nowp ? min&lt; int &gt; : max&lt; int &gt;)((nowp ? beta : alpha), alpha_beta(nowp ^ 1, nst, alpha, beta, ans)); } // 压行写法 if(alpha &gt;= beta) break; // alpha-beta剪枝 fst -= edge; } return nowp ? beta : alpha;}int main() { init(); cin &gt;&gt; T; for(int t = 1; t &lt;= T; t++) { cin &gt;&gt; n; int st = 0, p = 0, ans[2] = {0}; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; tmpx &gt;&gt; tmpy; int res = nextStep(st, st | (1 &lt;&lt; edg[tmpx][tmpy])); st = st | (1 &lt;&lt; edg[tmpx][tmpy]); if(res) { ans[p] += res; } else { p ^= 1; } } // 模拟 int res = alpha_beta(p, st, -0x3f3f3f3f, 0x3f3f3f3f, ans); cout &lt;&lt; \"Game \" &lt;&lt; t &lt;&lt; \": \"; if(res &gt;= 0) { cout &lt;&lt; \"A wins.\" &lt;&lt; endl; } else { cout &lt;&lt; \"B wins.\" &lt;&lt; endl; } } return 0;} 解法2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int edg[11][11];int tri[] = {(1 &lt;&lt; 0) + (1 &lt;&lt; 1) + (1 &lt;&lt; 2), (1 &lt;&lt; 3) + (1 &lt;&lt; 4) + (1 &lt;&lt; 7), (1 &lt;&lt; 2) + (1 &lt;&lt; 4) + (1 &lt;&lt; 5), (1 &lt;&lt; 5) + (1 &lt;&lt; 6) + (1 &lt;&lt; 10), (1 &lt;&lt; 8) + (1 &lt;&lt; 9) + (1 &lt;&lt; 15), (1 &lt;&lt; 7) + (1 &lt;&lt; 9) + (1 &lt;&lt; 11), (1 &lt;&lt; 11) + (1 &lt;&lt; 12) + (1 &lt;&lt; 16), (1 &lt;&lt; 10) + (1 &lt;&lt; 12) + (1 &lt;&lt; 13), (1 &lt;&lt; 13) + (1 &lt;&lt; 14) + (1 &lt;&lt; 17)};#define addedge(x, y, z) (edg[x][y] = edg[y][x] = z)const int full = (1 &lt;&lt; 18) - 1;int mm[full + 1];void init() { addedge(1, 2, 0); addedge(1, 3, 1); addedge(2, 3, 2); // ... // 本连边方式不推荐学习，因此部分内容已省略，相信有更好的方式 for(int i = 0; i &lt; full; i++) mm[i] = -0x3f3f3f3f; mm[full] = 0; return;}int T, n, tmpx, tmpy;int nextStep(int lst, int nst) { // lst 为之前状态 nst 为当前状态 int cnt = 0; for(int i = 0; i &lt; 9; i++) if((lst &amp; tri[i]) != tri[i] &amp;&amp; (nst &amp; tri[i]) == tri[i]) ++cnt; // 本次得分 return cnt;}int max_min(int nowp, int st) { if(mm[st] != -0x3f3f3f3f) return mm[st]; int fst = full ^ st, nst, maxx = -0x3f3f3f3f; while(fst) { int edge = fst &amp; (-fst); // 枚举连边 int res = nextStep(st, (nst = st | edge)); if(res) { maxx = max(maxx, res + max_min(nowp, nst)); } else { maxx = max(maxx, -max_min(nowp ^ 1, nst)); } fst -= edge; } return mm[st] = maxx;}int main() { init(); cin &gt;&gt; T; for(int t = 1; t &lt;= T; t++) { cin &gt;&gt; n; int st = 0, p = 0, ans[2] = {0}; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; tmpx &gt;&gt; tmpy; int res = nextStep(st, st | (1 &lt;&lt; edg[tmpx][tmpy])); st = st | (1 &lt;&lt; edg[tmpx][tmpy]); if(res) { ans[p] += res; } else { p ^= 1; } } // 模拟 int res = max_min(p, st); cout &lt;&lt; \"Game \" &lt;&lt; t &lt;&lt; \": \"; if((ans[p] + res &gt; ans[p ^ 1]) ^ p) { cout &lt;&lt; \"A wins.\" &lt;&lt; endl; } else { cout &lt;&lt; \"B wins.\" &lt;&lt; endl; } } return 0;} 后记不过这个题3s时限怕是有点水了。 然后还可以做 【九省联考2018】一双木棋chess，也可以使用max-min策略+记忆化搜索。","link":"/2019-12/19-luoguuva751/"},{"title":"项目日记 - 开发图片爬虫 Ⅰ","text":"用C++开发一个图片爬虫 Ⅰ ：获取网页内容 前言这个项目很久前就开始写了，但一直没有很完善。最近想起来，打算重新完善这个项目。 本教程仅适用于C++。内容较为复杂，可以根据自己需要来阅读。 目的做一个项目，首先需要知道你的目标是什么。这个项目名为图片爬虫，当然是为了下载图片。 再具体一点，用户先给出一个网址，我们先保存网页，抓取网页上的图片链接和其他网址链接。然后保存每一张图片到用户设置的文件夹中。深入其他网址链接，循环这一步骤。 那么我们去爬一个图片网站，就可以找到很多好（康）看的图片了。 理论先了解爬虫的定义，如下： 网络爬虫（英语：web crawler），也叫网络蜘蛛（spider），是一种用来自动浏览万维网的网络机器人。其目的一般为编纂网络索引。 对于这个东西我还想补充一下，爬虫操作不当可能是违法的，但对于我们这些小项目来说，请求服务器资源的速度一般达不到攻击服务器的要求。爬虫有一个国际互联网界通行的道德规范，名叫robots协议，有兴趣可以去了解一下。我们就先不管那么多，还是技术更要紧些，不干扰网站正常运行就行了。 那么如何去开发呢？我们目的很明确，所以大概分为几个步骤。我制作了一个流程图来演示： 现在对每个步骤进行解释，先设置爬取的网站，这个很简单。第一个要实现的就是如何获取网页，关于这个我做一个较为详细的理论说明。 关于用C++实现获取网页内容，我所知有两种方法，使用Winsock或WinInet。相信大家对这两个东西一定有所了解，不了解的可以细读定义。 先大致了解Winsock的定义： Windows Sockets API (WSA), 简短记为Winsock, 是Windows的TCP/IP网络编程接口（API）。 具体是什么可以再自行了解，我这个项目选择使用的是WinInet。 WinInet（“Windows Internet”）API帮助程序员使用三个常见的Internet协议，这三个协议是用于World Wide Web万维网的超文本传输协议（HTTP：Hypertext Transfer Protocol）、文件传输协议（FTP：File Transfer Protocol）和另一个称为Gopher的文件传输协议。WinInet函数的语法与常用的Win32 API函数的语法类似，这使得使用这些协议就像使用本地硬盘上的文件一样容易。 定义中已经说了，这个API非常容易使用，这也是我为什么选择使用它。 再补充一下，我最近又查阅到了第三种方法，使用WinHTTP。我会在以后的章节对它进行详细的说明。相比而言，它其实更适合对网页的操作。定义： Microsoft Windows HTTP Services(WinHTTP)为开发者提供了HTTP客户端应用程序编程接口(API)，用于通过HTTP协议向其他HTTP服务器发送请求。 在官方有WinHTTP与WinInet的对比，如果用简短的话来说明他俩的关系，那就是： 除了少数例外，WinInet是WinHTTP的超集。在两者之间进行选择时，应使用WinInet，除非您计划在需要模拟和会话隔离的服务或类似服务的进程中运行。 如果还想了解更多WinInet与WinHTTP的区别，可以看官方英文文档。 实战相信大家已经对这些东西都有了大致了解，那么就开始写代码了。输入网址的主程序代码就不给出了，我先放出获取页面的代码实例，是从网上找到并改编之后的。 1234567891011121314151617181920212223242526#include &lt;wininet.h&gt;#define MAXBLOCKSIZE 1024 * 1024void downloadUrl(const char *Url, const char *FilePath) { static byte Temp[MAXBLOCKSIZE]; HINTERNET hSession= InternetOpenA(\"DownloadKit\", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0), hOpenUrl= 0; if(hSession != NULL) { hOpenUrl= InternetOpenUrlA(hSession, Url, NULL, 0, INTERNET_FLAG_DONT_CACHE, NULL); if(hOpenUrl == NULL) goto fail; FILE *stream= fopen(FilePath, \"wb\"); ULONG Number= 1; while(Number &gt; 0) { InternetReadFile(hOpenUrl, Temp, MAXBLOCKSIZE, &amp;Number); fwrite(Temp, sizeof(char), Number, stream); } fclose(stream); if(hOpenUrl) InternetCloseHandle(hOpenUrl); if(hSession) InternetCloseHandle(hSession); return; }fail: if(hOpenUrl) InternetCloseHandle(hOpenUrl); if(hSession) InternetCloseHandle(hSession); printf(\"Internet Error\\n\"); return;} 先大致说明一下函数参数，Url为你想下载网页的网址，filePath为保存到电脑的路径。 你可以找一个网址，选一个存文件的路径，调用函数并编译，你会发现这段代码是无法通过编译的，因为还需要连接静态链接库。 如果使用Visual Studio，需要在函数之前加入以下这句，并且忽略编号为4996的警告。1#pragma comment(lib, \"wininet.lib\") 如果使用MinGW，需要添加编译命令来/MinGW64/lib/libwininet.a文件。如果使用DevC++还可以通过项目属性来添加，这里不作细说。如果遇到了其他困难可以下方留言，我将会在第一时间解答。 InternetOpenA先来讲解InternetOpenA函数。这个是我头文件里的定义。如果你使用Unicode遍码就改成InternetOpenW，用法类似。1234567INTERNETAPI_(HINTERNET) InternetOpenA( _In_opt_ LPCSTR lpszAgent, _In_ DWORD dwAccessType, _In_opt_ LPCSTR lpszProxy, _In_opt_ LPCSTR lpszProxyBypass, _In_ DWORD dwFlags );lpszAgent指向一个空结束的字符串，用来设置UserAgent。对于我们用处不大，可以随意设置。 dwAccessType指定访问类型，用于是否使用代理或注册表配置。我们选择使用IE代理，如果想设置代理服务器则使用INTERNET_OPEN_TYPE_PROXY。数值表： 数值 说明 INTERNET_OPEN_TYPE_DIRECT 使用直接连接网络。 INTERNET_OPEN_TYPE_PRECONFIG 获取代理或直接从注册表中的配置，使用代理连接网络。 INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY 获取代理或直接从注册表中的配置，并防止启动Microsoft JScript或Internet设置（INS）文件的使用。 INTERNET_OPEN_TYPE_PROXY 通过代理的请求，除非代理旁路列表中提供的名称解析绕过代理,在这种情况下，该功能的使用。 lpszProxy指向一个空结束的字符串，该字符串指定的代理服务器的名称，我们此参数应该设置为NULL。设置代理还要在这里深入研究，由于比较麻烦，我们先不去了解了。 lpszProxyBypass指向一个空结束的字符串，该字符串指定的可选列表的主机名或IP地址。我们此参数也设置为NULL。 dwFlags是设定一些要求的，值可以组合组合，我们设置为0。数值表： 数值 说明 INTERNET_FLAG_ASYNC 使异步请求处理的后裔从这个函数返回的句柄。 INTERNET_FLAG_FROM_CACHE 不进行网络请求，从缓存返回的所有实体，如果请求的项目不在缓存中，则返回一个合适的错误，如ERROR_FILE_NOT_FOUND。 INTERNET_FLAG_OFFLINE 同INTERNET_FLAG_FROM_CACHE。 Return Value即返回值是一个HINTERNET句柄，用于接下来的WinINet函数。计算机正常且函数参数规范的情况下，都能够成功返回。如果返回NULL就是失败了，那么请检查自己的参数。 InternetOpenUrlA接下来就是用于打开网页的InternetOpenA函数了，如果使用Unicode编码请改为InternetOpenUrlW。 相比而言，这个函数参数比较多。 12345678INTERNETAPI_(HINTERNET) InternetOpenUrlA( _In_ HINTERNET hInternet, _In_ LPCSTR lpszUrl, _In_reads_opt_(dwHeadersLength) LPCSTR lpszHeaders, _In_ DWORD dwHeadersLength, _In_ DWORD dwFlags, _In_opt_ DWORD_PTR dwContext ); hInternet为当前的Internet会话句柄，也就是我们刚刚使用InternetOpen 函数返回的句柄。 lpszUrl指向一个空结束的字符串，用于指定读取的网址。非常容易理解。 lpszHeaders指向一个空结束的字符串，指定发送到HTTP服务器的头信息。我们不必做过多了解，设为NULL即可。 dwHeadersLength指定的长度，字符，额外的标头。对于我们说也没什么用，设为0即可。 dwFlags设定一些要求，我们设置的INTERNET_FLAG_NO_CACHE，与INTERNET_FLAG_NO_CACHE_WRITE有相同作用。有较多数值，可以了解后选择其中一个。数值表： 数值 说明 INTERNET_FLAG_EXISTING_CONNECT 如果使用相同的必须属性创建会话，会尝试利用现有的InternetConnect对象。这只对FTP操作非常有用，因为FTP是唯一在同一会话中执行多种操作的协议。WinINet API 为每个由InternetOpen产生的HINTERNET句柄缓冲一个单独链接句柄。InternetOpenUrl使用此标志的HTTP和FTP连接。 INTERNET_FLAG_HYPERLINK 当决定何时从网络重载时，如果服务器没有返回 Expires time 和 LastModified，那么强制重载。 INTERNET_FLAG_IGNORE_CERT_CN_INVALID 停用检查从服务器对必须的主机名称返回的SSL/PCT-based证书。 WinINet函数使用简单的比较匹配主机名称和通配符的规则检查证书。 INTERNET_FLAG_IGNORE_CERT_DATE_INVALID 停用检查的SSL/PCT-based的证书的适当的有效日期。 INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP 禁用检测这中特殊的重定向。当使用此标志， WinINet 透明允许从HTTPS到HTTP URL的重定向。 INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS 禁用检测这中特殊的重定向。当使用此标志， WinINet 透明的允许的HTTP到HTTPS URL的重定向。 INTERNET_FLAG_KEEP_CONNECTION 如果可能的话，为连接使用保活语义。这个标志要求微软网络（ MSN ），NTLM和其他类型的身份验证。 INTERNET_FLAG_NEED_FILE 如果要创建的文件不能被缓存，创建临时文件。 INTERNET_FLAG_NO_AUTH 不试图自动验证。 INTERNET_FLAG_NO_AUTO_REDIRECT 不自动处理HttpSendRequest中的重定向。s INTERNET_FLAG_NO_CACHE_WRITE 不添加返回实体到缓存。 INTERNET_FLAG_NO_COOKIES 不会自动添加的Cookie头到请求，并且不自动添加返回的cookie到cookie数据库。 INTERNET_FLAG_NO_UI 禁用Cookie的对话框。 INTERNET_FLAG_PASSIVE 使用被动FTP语义。InternetOpenUrl为FTP的文件和目录使用此标志。 INTERNET_FLAG_PRAGMA_NOCACHE 即使代理中存在缓存副本，也强制要求由源服务器返回。 INTERNET_FLAG_RAW_DATA 检索的Gopher目录信息时，传回的数据作为GOPHER_FIND_DATA结构，如果检索的FTP目录信息时，作为一个WIN32_FIND_DATA结构。如果此标志没有指定，或者请求通过CERN代理创建， InternetOpenUrl返回的HTML版本的目录。 INTERNET_FLAG_RELOAD 从原服务器强制下载所要求的文件，对象，或目录列表，而不是从缓存下载。 INTERNET_FLAG_RESYNCHRONIZE 重新加载的HTTP资源，如果资源在最后一次下载后已被修改。所有FTP和Gopher资源将被重载。 INTERNET_FLAG_SECURE 使用安全传输语义。这次传输使用安全套字节层/专用通信技术（的SSL / PCT ），这只有在HTTP请求时有意义。 dwContext为指向一个变量的指针，将随着返回的句柄，一起传递给回调函数。有兴趣可以自行查阅，我们设为NULL即可。 Return Value即返回值，若成功连接则返回一个有效的HINTERNET句柄，如果失败将放回NULL。如果失败可以使用GetLastError检索特定的错误讯息。请调用InternetGetLastResponseInfo确定为什么对服务器的访问被拒绝，这些函数大家有兴趣可以查阅更多资料来了解。 FILE这一步就不作过多讲解了，只简单介绍这几个函数。 fopen用来打开文件，返回文件指针。1FILE * fopen(const char * path, const char * mode);fwrite用于向文件中写入一个数据块，可以看实际代码自行理解。1size_t fwrite(const void * ptr, size_t size, size_t count, FILE * stream);fclose用于关闭一个流。1int fclose(FILE * stream); InternetReadFileInternetReadFile的官方定义为，从一个由InternetOpenUrl，FtpOpenFile或HttpOpenRequest函数打开的句柄中读取数据。我们使用它来将网页上的内容保存到一个字符数组中。 InternetReadFile函数每次获取的内容长度有限，所以应多次调用，直到全部获取完毕。 123456BOOLAPI InternetReadFile( _In_ HINTERNET hFile, _Out_writes_bytes_(dwNumberOfBytesToRead) __out_data_source(NETWORK) LPVOID lpBuffer, _In_ DWORD dwNumberOfBytesToRead, _Out_ LPDWORD lpdwNumberOfBytesRead ); hFile为InternetOpenUrl，FtpOpenFile或HttpOpenRequest函数返回的句柄。我们使用InternetOpenUrl获得的HINTERNET句柄。 lpBuffer为指向缓冲器的指针。因此我们需要定义一个字符数组，然后将它作为参数。 dwNumberOfBytesToRead为要读取的字节数。这个需要根据自己的网络情况，我使用的为1024 * 1024，也就是1M。 lpdwNumberOfBytesRead为接收读取字节量的变量。我们用它来判断是否将网页内容全部获取完毕。 Return Value即返回值，成功为TRUE，失败为FALSE。若失败可用GetLastError查看更多错误信息。 InternetCloseHandle到这，获取网页的代码基本完工了。但做事应善始善终，那些句柄占用的资源还需要释放。InternetCloseHandle函数用来关闭一个Internet句柄。 123BOOLAPI InternetCloseHandle( _In_ HINTERNET hInternet ); hInternet为要关闭的句柄。我们要依次关闭那俩个HINTERNET句柄。 Return Value即返回值，成功为TRUE，失败为FALSE。若失败可用GetLastError查看更多错误信息。 小结其实获取网页内容的代码是非常简单的，然而其中还蕴含着许许多多的知识。这段代码不仅可以获取网页，也可以用来获取图片或其他格式的文件。 这段函数下载后一般为Unicode编码文件，下一节我将讲解如何将它转换为ASCII编码。","link":"/2019-05/26-spiking1/"},{"title":"项目日记 - 开发图片爬虫 Ⅲ","text":"用C++开发一个图片爬虫 Ⅲ ：URL预处理 【咕咕】封面图片来自网络，如有侵权将删除。 前言上一节说这节介绍WinHTTP，现在好像鸽子了。经过我再三思考后，还是先深入学习WinInet吧。 关于根据链接下载网页的各种方式在第一节已经介绍过了。这里再补充一下，还有一种方式是使用外部库libcurl，使用方便代码简洁，但我不把它当做我们主要学习的对象，因为它太过于简单。 这节可以说是个扩展篇，并不是这个项目优先考虑的内容。先介绍它主要是因为这部分东西更有意思，大家可能会更感兴趣。 目的这个预处理是我自己勉强定义的，所以大家可能不理解。 通俗的说，URL预处理意为对一个URL链接本体进行处理，请大家不要误以为是对HTML网页内容进行分析。 再说清楚一些，获取链接所指向的内容前，程序并不知道这个内容是什么类型的。也就是说，它可能是一个HTML也可能是图片，又或者是一个CSS文件。所以我们要对URL进行一定的预处理，然后判断文件后缀之类的。 先给出本节流程图： 很多人可能不理解获得内容类型为什么需要先分解URL，那就接着往下看。 理论从基础说起，大家都模糊地知道URL是什么，我给出它的定义： URL是统一资源定位符（英语Uniform Resource Locator的缩写）也被称为网页地址，是因特网上标准的资源的地址。它最初是由蒂姆·伯纳斯·李发明用来作为万维网的地址。现在它已经被万维网联盟编制为互联网标准RFC1738了。 URL由多部分组成，详细说有9部分，我们一个一个介绍。有关资料部分来自于going_han的博客。 一个URL的实例: scheme://user:password@host:port/path;params?query#frag 编号 名称 介绍 1 协议(protocol) 为进行网络中的数据交换而建立的规则、标准或约定。有时也叫scheme，常用的协议有http、https、ftp、file、mailto。 2 用户名(user) 一般用不到，为访问资源使用的用户名。 3 密码(password) 一般也用不到，为访问资源使用的密码。 4 域名(domain) 域名（英语：Domain Name），简称域名、网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。有时也叫host，可以使用IP地址作为域名使用。 5 端口(port) 在网络技术中，端口（Port）有好几种意思。我们这里所指的端口不是指物理意义上的端口，而是特指TCP/IP协议中的端口，是逻辑意义上的端口。端口不是一个必须部分，如果省略将采用协议默认使用的端口。 6 路径(path) 由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。 7 参数(params) 这是用于指定特殊参数的可选项。 8 查询(query) 可选项。用于给动态网页传递参数，可有多个参数，用“&amp;”符号隔开，每个参数的名和值用“=”符号隔开。 9 片段(frag) 主要用于对资源进行分类。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释。访问一个帮助文档时，文档的各个章节就可以表述为片段。 所以分解URL有什么用呢？我们再简单了解一下HTTP访问的步骤，HTTP访问时会进行多步操作，其中有两步我想重点介绍一下，分别是：发送请求头(Request Headers)和接受响应头(Response Headers)。 其实大家现在就可以直观的了解它，介绍一种方法。 随便找一个可用网页（比如这篇博客） -&gt; 点击键盘上的F12，弹出开发人员调试工具 -&gt; 进入’Network’选项页 -&gt; 点击录制按钮（黑色的圆点），按钮变红色 -&gt; 刷新页面。 然后会有很多信息，我们要找的一般在第一个位置，Name一般为URL最后一个’/‘后的字符串。如果是在这篇博客进行的上述操作，则Name为’03-spiking3/‘，点击会显示详细信息。 我使用的浏览器效果如下图，部分进行了打码处理，URL为localhost是因为我在本地测试。 这里已经很直观了，我们需要的就是Response Headers中的’Content-Type:text/html’，这个可以用来判断内容的类型。大家可以再打开一个图片URL进行观察，比如上面那个截图，发现其中’Content-Type:image/png’。我们根据此信息来判断内容的类型。 其他信息大家可以自行了解，对项目作用不大，我就不作介绍了。 另外，本节含有大量string类的内容，但只要不是初学者都很熟悉了，因此不作理论上的介绍。 实战这部分理论易理解，但代码部分比较长。先给出本节所有的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465string _trim(const string &amp;str) { size_t start= str.find_first_not_of(\" \\n\\r\\t\"); size_t until= str.find_last_not_of(\" \\n\\r\\t\"); string::const_iterator i= start == string::npos ? str.begin() : str.begin() + start; string::const_iterator x= until == string::npos ? str.end() : str.begin() + until + 1; return string(i, x);}void parse_url(const string &amp;raw_url, string &amp;port, string &amp;domain, string &amp;path) { string x= _trim(raw_url), protocol, query; int offset= 0; size_t pos1, pos2, pos3, pos4; offset= offset == 0 &amp;&amp; x.compare(0, 8, \"https://\") == 0 ? 8 : offset; offset= offset == 0 &amp;&amp; x.compare(0, 7, \"http://\") == 0 ? 7 : offset; pos1= x.find_first_of('/', offset + 1); path= pos1 == string::npos ? \"\" : x.substr(pos1); domain= string(x.begin() + offset, pos1 != string::npos ? x.begin() + pos1 : x.end()); path= (pos2= path.find(\"#\")) != string::npos ? path.substr(0, pos2) : path; port= (pos3= domain.find(\":\")) != string::npos ? domain.substr(pos3 + 1) : \"0\"; domain= domain.substr(0, pos3 != string::npos ? pos3 : domain.length()); protocol= offset &gt; 0 ? x.substr(0, offset - 3) : \"\"; query= (pos4= path.find(\"?\")) != string::npos ? path.substr(pos4 + 1) : \"\"; path= pos4 != string::npos ? path.substr(0, pos4) : path; return;}void judgeUrlType(const char *Url, string &amp;fileSuffix) { static byte Temp[MAXBLOCKSIZE]; HINTERNET hSession= InternetOpenA(\"DownloadKit\", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0), hConnect= 0, hRequest= 0; if(hSession != NULL) { INTERNET_PORT nPort= 0; DWORD dwReadSize= MAXBLOCKSIZE; string sPort, sServer, sObject; parse_url(Url, sPort, sServer, sObject); for(size_t i= 0; i &lt; sPort.size(); i++) nPort= nPort * 10 + sPort[i] - '0'; hConnect= InternetConnectA(hSession, sServer.c_str(), nPort, NULL, NULL, INTERNET_SERVICE_HTTP, 0, NULL); if(hConnect == NULL) goto fail; hRequest= HttpOpenRequestA( hConnect, \"GET\", sObject.c_str(), NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION | INTERNET_FLAG_NO_AUTH | INTERNET_FLAG_NO_COOKIES | INTERNET_FLAG_NO_UI | INTERNET_FLAG_IGNORE_CERT_CN_INVALID | INTERNET_FLAG_RELOAD, NULL); if(hRequest == NULL || !HttpSendRequest(hRequest, NULL, 0, NULL, 0)) goto fail; if(!HttpQueryInfoA(hRequest, HTTP_QUERY_RAW_HEADERS, Temp, &amp;dwReadSize, NULL)) goto fail; Temp[dwReadSize]= '\\0'; for(unsigned long i= 0; i &lt; dwReadSize; i= i + strlen((const char *)Temp + i) + 1) { if(string((const char *)Temp + i).compare(0, 13, \"Content-Type:\") == 0) { printf(\"%s\\n\", Temp + i + 14); fileSuffix= \"\"; fileSuffix= (string((const char *)Temp + i + 14).compare(\"text/html\") == 0) ? \"html\" : fileSuffix; fileSuffix= (string((const char *)Temp + i + 14).compare(\"image/png\") == 0) ? \"png\" : fileSuffix; fileSuffix= (string((const char *)Temp + i + 14).compare(\"image/jpeg\") == 0) ? \"jpg\" : fileSuffix; fileSuffix= (string((const char *)Temp + i + 14).compare(\"image/gif\") == 0) ? \"gif\" : fileSuffix; // Add what you want break; } } if(hRequest) InternetCloseHandle(hRequest); if(hConnect) InternetCloseHandle(hConnect); if(hSession) InternetCloseHandle(hSession); return; }fail: if(hRequest) InternetCloseHandle(hRequest); if(hConnect) InternetCloseHandle(hConnect); if(hSession) InternetCloseHandle(hSession); printf(\"Internet Error\\n\"); return;} _trim函数作用为去除字符串的空白换行符。 parse_url函数作用为分解URL，分解为端口、域名和路径。 judgeUrlType函数作用为获得HTTP响应头并分析URL内容类型。 string本节使用C++STL中的string类比较多，简单的大家都使用过，所以介绍一下几个比较陌生的函数。 find_first_not_of1234size_t find_first_not_of (const string&amp; str, size_t pos = 0) const;size_t find_first_not_of (const char* s, size_t pos = 0) const;size_t find_first_not_of (const char* s, size_t pos, size_t n) const;size_t find_first_not_of (char c, size_t pos = 0) const; Return Value即返回值，返回第一个不匹配字符的位置，如果没有不匹配字符则返回string::npos。若使用字符串作参数，则此处不匹配字符指参数中不包含的字符。 string::npos1static const size_t npos = -1; find_last_not_of1234size_t find_last_not_of (const string&amp; str, size_t pos = npos) const;size_t find_last_not_of (const char* s, size_t pos = npos) const;size_t find_last_not_of (const char* s, size_t pos, size_t n) const;size_t find_last_not_of (char c, size_t pos = npos) const; Return Value即返回值，与find_first_not_of类似，返回最后一个不匹配字符的位置。 substr1string substr (size_t pos = 0, size_t len = npos) const; Return Value即返回值，返回从pos开始长度为len的子串。 InternetConnectA","link":"/2019-06/03-spiking3/"},{"title":"技巧 - 如何优雅的写代码","text":"本篇分享写代码相关的一些技巧，可用且不仅用于OIer。 相关内容：DevC++、Visual Studio Code、MinGW、Git、Github 前言临退役，将自己写代码一年多的经验分享给后人。可能用处不大，也可以当个说明书看。 内容仅供参考。 编辑器DevC++适合初学者使用，优点是上手容易、功能均衡，即可用来写题，也可用来写简单项目。 然而缺点也很多，自带mingw版本较低，调试能力较低，经常卡死，各种BUG。 写题这个上手就会，还是有一些技巧的。这里默认使用5.11版本，应该是最新版。 并且CSP好像只能用这个编辑器。 配置此编辑器一般来说无需配置就能使用。 代码补全其实一直是存在的，然而使用的快捷键和输入法冲突了，你只能等待自动出代码补全。其实可以手动更改！ 步骤：工具-&gt;快捷键选项-&gt;Show Code Completion，将快捷键改成你想要的。 在写代码时按下快捷键即可弹出补全对话框进行选择，当然有时会出现BUG。 AStyle代码格式化工具，能简单格式化代码。默认快捷键Ctrl+Shift+A。 步骤：Astyle-&gt;格式化选项，支持多种风格，可以自行了解。 代码模板提供了大量代码模板，可以自己添加删除，软件自带一些模板。 先说如何更改，步骤：工具-&gt;编辑器属性-&gt;代码-&gt;插入，先点击添加再写代码，其中*|*代表待填位置。点击移除可以移除不想要的。 那么如何使用？软件左上角 自带的几个模板在写项目时经常使用。 缺省源在原来机房盛行DevC++时非常热门，应该说非常好用了。创建空文件自动写入缺省源内容，缺点就是如果缺省源出锅，写的程序都将出现相同问题。 步骤：工具-&gt;编辑器属性-&gt;代码-&gt;缺省源，更改后确定即可。 编译器选项如果想自己加高版本的编译器，就这样做吧。 步骤：工具-&gt;编译选项-&gt;由文件夹添加编译器设置-&gt;选择文件夹（你下载的mingw)，这样是最方便的。 Visual Studio Code非常好的一款编辑器，优点是功能全面、可扩展性高、打开文件速度快、手感极佳、安装较方便。 当然也有一点缺点和问题，对C++的支持仍需改进，GDB调试监视变量需要优化，文件夹及文件名不支持汉字，写项目不易配置。 但是我还是非常推荐，写前端、JS非常好用。 基本插件Chinese language简体中文支持，自己选择一个喜欢的图标主题、主题。 编写调试C++首先需要下载扩展C/C++，才能正常编写调试C++。 然后进行配置，如果你不使用调试可以使用另一种方法。 先创建一个文件夹并通过vscode打开，下载mingw，此文章后面会给出下载地址。 然后在当前打开的文件夹下创建一个名为.vscode的文件夹（若未自动创建），再创建一个名为c_cpp_properties.json的文件，然而这步现在似乎可有可无，不过做了也没有坏处。 将以下内容写入c_cpp_properties.json文件： 1234567891011121314151617181920212223242526272829{ \"configurations\": [ { \"name\": \"Win32\", \"includePath\": [ \"${workspaceFolder}/**\", \"D:/Ciyang/mingw64/include\", \"D:/Ciyang/mingw64/x86_64-w64-mingw32/include\", \"D:/Ciyang/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include\", \"D:/Ciyang/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++\", \"D:/Ciyang/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward\", \"D:/Ciyang/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"intelliSenseMode\": \"gcc-x64\", \"browse\": { \"path\": [ \"${workspaceFolder}\" ], \"limitSymbolsToIncludedHeaders\": true } } ], \"version\": 4} includePath中的D:/Ciyang/mingw64改为你的mingw路径，都改为可用的存在的路径，甚至你可以用DevC++自带的mingw。 其他不需要管，可以自行查阅，不影响正常编写代码。现在创建一个HelloWorld.cpp，随便写一些代码，如果有莫名其妙的报错先不用管。 在vscode中，F5可以调试运行。现在我们按下F5，将会显示没有配置launch.json，然后就可以点击创建。（当然你可以自己在.vscode文件夹中创建launch.json文件）。 将以下内容写入launch.json文件： 1234567891011121314151617181920212223242526{ \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"C++ Luauch (GDB)\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${fileDirname}/${fileBasenameNoExtension}.exe\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${fileDirname}\", \"environment\": [], \"externalConsole\": true, \"preLaunchTask\": \"build-bug\", \"MIMode\": \"gdb\", \"miDebuggerPath\": \"D:/mingw64/bin/gdb.exe\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true } ] } ]} 悬停一些字符串上面会显示帮助信息，miDebuggerPath需要改为你的gdb路径，一般在mingw/bin中。 preLaunchTask是预启动任务，通俗来说，启动程序前运行的任务。如果你想每次运行程序都重新编译，就需要设置。 这时候回到cpp再按F5就会让你配置任务，在.vscode文件夹中创建tasks.json文件，我们将要配置编译任务。 将以下内容写入tasks.json文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344{ \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"build\", \"command\": \"g++\", \"args\": [ \"\\\"${file}\\\"\", \"-o\", \"\\\"${fileDirname}\\\\${fileBasenameNoExtension}\\\".exe\", \"-O2\" ], \"type\": \"shell\", \"problemMatcher\": [ \"$gcc\" ] }, { \"label\": \"build-bug\", \"command\": \"g++\", \"args\": [ \"-g\", \"\\\"${file}\\\"\", \"-o\", \"\\\"${fileDirname}\\\\${fileBasenameNoExtension}\\\".exe\" ], \"type\": \"shell\", \"problemMatcher\": [], }, { \"label\": \"build-bug-Wall\", \"command\": \"g++\", \"args\": [ \"-g\", \"-Wall\", \"\\\"${file}\\\"\", \"-o\", \"\\\"${fileDirname}\\\\${fileBasenameNoExtension}.exe\\\"\" ], \"type\": \"shell\", \"problemMatcher\": [], } ]} 共有三个任务，分别是build（开启O2优化编译程序）、build-bug（开启调试信息编译程序）、build-bug-Wall（开启调试信息并打开最多的警告编译程序）。 其中有些${file}、${fileDirname}等为vscode提供的变量，将自动转换为一些内容。 现在再按下F5，即可运行程序，F9设置断点即可暂停程序。 更多内容可以看：https://code.visualstudio.com/docs/editor/tasks#vscode 编写运行C++上面的方法过于复杂，还有一种简单的方法。下载C/C++ Compile Run插件 下载后，直接按F6即可自动编译cpp文件并运行。 现在发现有很多BUG，不推荐使用。 代码格式化vscode支持代码格式化，并且无需配置，快捷键Alt + Shift + F。 当然，某些语言可以下载插件进行格式化。也可以自定义格式化，我写过具体的步骤。 方法：毒瘤码风推荐 相关问题 Q: 头文件一直报错？A: 有时候出BUG无法解决，请重启vscode。如果一直报错请下载名为Include Autocomplete的扩展。 Q: 库关键字报错？A: 检查c_cpp_properties.json文件。 编译器这里只介绍MinGW。 MinGW此工具包含G++、GCC，并且可以安装很多C++库，可以直接选择下载配置完成的版本。 下载方式安装版：https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/installer/mingw-w64-install.exe/download 机房的电脑一直安装失败，安装版似乎需要科学上网。 解压版：https://sourceforge.net/projects/mingw-w64/files/Toolchains targetting Win64/Personal Builds/mingw-builds/8.1.0/threads-win32/sjlj/x86_64-8.1.0-release-win32-sjlj-rt_v6-rev0.7z 旧版本安装版：https://sourceforge.net/projects/mingw/files/latest/download 环境变量下载安装（解压）后，仍需要配置环境变量。 步骤：右键计算机-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;系统变量-&gt;找到path。 如果是win7点击编辑，将原来的mingw路径删掉，我们机房电脑开机就有个Cena评测机的mingw。在末尾添加新下载的mingw/bin路径，如D:\\Ciyang\\mingw64\\bin，不要忘了分号。 如果是win10，将原有的mingw移除，添加新下载的mingw路径，与win7同理。 在终端（cmd或powershell）中输入g++ --version查看版本号是否与下载的一致，如果未知指令表明未成功配置。 编译指令常用的有-o、-g、-O2、-Wall，还有扩大栈内存指令。 更多指令，可以看：https://www.cnblogs.com/bugutian/p/4490902.html 相关问题 Q: 为什么配置完环境变量，vscode（cmd）仍显示未知指令？A: 请确保更改环境变量后重启了vscode（cmd）。 远程仓库所以为什么要讲远程仓库的使用？当然是存储代码和工作区配置，为了不同电脑（机房、自己的笔记本）能快速同步。 Git主要是为了更加酷炫，存储代码，还有搭博客。 下载方式官方链接：https://git-scm.com/ 不科学上网下载完成率0.1%。 镜像下载：https://github.com/waylau/git-for-win 基本命令随机找到一个指南：https://www.bootcss.com/p/git-guide/ Github建立仓库步骤：注册一个账号并登录-&gt;右上角点击加号-&gt;New Repositorie-&gt;填写Repository name（库名）-&gt;可填写Description（描述）-&gt;选择Private（私有）-&gt;可选择license授权规则-&gt;选择.gitignore-&gt;Create。 如果要存储不能公开的信息就选择Private，如果都可以公开也可以设为Public。 如果要存储写的C++代码，推荐.gitignore选择C++，就不会存储exe文件和一些其他烂七八糟的文件。 ssh配置一般来说我们可以用https链接对github进行访问，当然选择ssh更加安全。 随机找了个教程：https://blog.csdn.net/u013778905/article/details/83501204 增加远程仓库我理解为给远程仓库地址起个别名 12git remote add &lt;name&gt; &lt;address&gt;example : git remote add cw https://github.com/Xciyang/CodeWork.git 更新本地仓库/拉取远程仓库一般称作更新、拉取。 1234git fetch &lt;name&gt; &lt;branch&gt;example : git fetch cw mastergit pull &lt;name&gt; &lt;branch&gt;example : git pull cw master 暂存更改如果你写了一道新题，改了一些代码，就会造成一些更改。此命令默认会按照当前文件夹下的.gitignore进行忽略。.为暂存所有更改。 12git add &lt;file&gt;git add . 查看当前状态查看当前暂存的更改。 1git status 提交提交当前暂存的更改，并附加某些信息 1git commit -m &quot;Message&quot; 推送远程仓库12git push &lt;name&gt; &lt;branch&gt;example : git push cw master 更多如果安装了Git，并且存在.git文件夹，vscode会自动启用源代码管理插件。还是比较好用的，通过点击就能帮你使用指令拉取提交推送文件。你唯一要做的事就是增加仓库。 拉取代码的步骤：增加仓库-&gt;拉取自-&gt;选择仓库。 推送代码的步骤：增加仓库-&gt;更改文件-&gt;暂存所有更改-&gt;编辑消息-&gt;全部提交-&gt;推送到-&gt;选择仓库，然后就完成了一次上传。 相关问题 Q: Connection reset by [server_ip] port 22 ？A: 发现是网络问题，多试几次就好了。 最后如果有什么需要解决的问题可以评论或其他方式指出，希望能帮到一些人。","link":"/2019-10/08-you-ya-de-xie-dai-ma/"},{"title":"项目日记 - 开发图片爬虫 Ⅱ","text":"用C++开发一个图片爬虫 Ⅱ ：编码转换 前言我们上一节学习了获取网页的代码，那么大家可能会以为接下来就是分析网页了。但事实上，我们还需要先转换编码。我们都知道，C++编程常用的是ASCII编码，而网页大部分使用的是UTF-8编码。 因此我们要先将获取后的网页转换成我们想要的编码，再去分析内容。 理论我们写编码转换的代码，肯定要知道这些编码之间的关系。 ASCII编码我们再熟悉不过了，然而我相信很多人和我一样，分不清什么是Unicode，UTF-8，UTF-16，UTF-32。 我不想用长篇大论来解释这些东西，就给出它们各自的定义和我们需要知道的东西。如果想更深入的了解，可以自行搜索。 Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准，包括字符集、编码方案等。 至于它为什么诞生，我简单说明一下。因为我们熟知的ASCII码能表示的字符是非常有限的，根本无法承受那么多国家的字符。因此国际组织就又发明了一个新的编码，几乎收尽所有国家的字符，甚至包括特殊字符。 Unicode与其他编码类似，也是每一个字符都对应一个数字来表示它。但Unicode也仅仅如此，它没有规定这个二进制代码如何存储。 那么问题来了，在Unicode编码下，假设有一个3字节的二进制代码，计算机怎么知道表示的是一个字符还是两个字符或者是三个字符呢？因此UTF-8、UTF-16这一系列东西就诞生了。 先介绍UTF-8，这是开发网页首选的编码存储方式。 UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，又称万国码，由Ken Thompson于1992年创建。 如果略懂编码的话，可变长度是最大特点。但是为了实现可变长度，就需要一些二进制位来表示长度，我认为它的编码规则可以说是非常典型了。 字节数 二进制编码形式 1字节 0xxxxxxx 2字节 110xxxxx 10xxxxxx 3字节 1110xxxx 10xxxxxx 10xxxxxx 4字节 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 5字节 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 6字节 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 再简单说一下UTF-16，定义： UTF-16是Unicode字符编码五层次模型的第三层：字符编码表（Character Encoding Form，也称为 “storage format”）的一种实现方式。 UTF-16虽然也可变长度，但不如UTF-8灵活。它有大尾序和小尾序两种储存形式，这个可以自行查阅。 UTF-32 (或 UCS-4)是一种将Unicode字符编码的协定，对每一个Unicode码位使用恰好32位元。其它的Unicode transformation formats则使用不定长度编码。 网上找到一个工具，Unicode和UTF编码转换，有兴趣可以试一下。 实战我们为什么要了解上面那些东西，最终还是为了更容易理解代码。先给出一个将一个字符串从UTF-8转为ASCII的示例代码，从网上抄下来的。 123456789101112const char *changeTxtEncoding(const char *szU8) { int wcsLen= MultiByteToWideChar(CP_UTF8, NULL, szU8, strlen(szU8), NULL, 0); wchar_t *wszString= new wchar_t[wcsLen + 1]; MultiByteToWideChar(CP_UTF8, NULL, szU8, strlen(szU8), wszString, wcsLen); wszString[wcsLen]= '\\0'; int ansiLen= WideCharToMultiByte(CP_ACP, NULL, wszString, wcslen(wszString), NULL, 0, NULL, NULL); char *szAnsi= new char[ansiLen + 1]; WideCharToMultiByte(CP_ACP, NULL, wszString, wcslen(wszString), szAnsi, ansiLen, NULL, NULL); szAnsi[ansiLen]= '\\0'; delete[] wszString; return szAnsi;} 此函数是将一个字符串，先从UTF-8转为UTF-16，再转为ASCII。 MultiByteToWideChar此函数可将字符串映射到UTF-16(宽字符)字符串。字符串不一定来自多字节字符集。在这里，字符集或代码页我们都可以理解为编码映射表。12345678int WINAPI MultiByteToWideChar( _In_ UINT CodePage, _In_ DWORD dwFlags, _In_NLS_string_(cbMultiByte) LPCCH lpMultiByteStr, _In_ int cbMultiByte, _Out_writes_to_opt_(cchWideChar,return) LPWSTR lpWideCharStr, _In_ int cchWideChar );定义简化如下：12345678int WINAPI MultiByteToWideChar( UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar );CodePage为指定执行转换的字符集。如果原字符串为ASCII通常选择CP_ACP，关于CP_ACP与CP_THREAD_ACP的区别可以自己了解。我们这里原字符串为UTF-8，因此选择CP_UTF8。数值表： 数值 说明 CP_ACP Windows系统默认的ANSI代码页。 CP_MACCP Mac系统代码页。 CP_ACP OEM系统代码页。 CP_SYMBOL 符号字符集。 CP_THREAD_ACP 当前Windows线程的ANSI代码页。 CP_UTF7 使用UTF-7。 CP_UTF8 使用UTF-8。 dwFlags设定转换类型。缺省值为MB_PRECOMPOSED，对于UTF-8必须为0或MB_ERR_INVALID_CHARS，此参数作用较小，数值表就不给出了。 lpMultiByteStr指向一个要转换的字符串。 cbMultiByte指定长度，如果lpMultiByteStr指向的字符串为空结束，此参数可设为-1。如果设为-1，函数将处理包括终止空字符在内的所有字符。我们可以用strlen来自行获得长度。 lpWideCharStr为指向接收缓冲器的指针。 cchWideChar为lpWideCharStr指示的缓冲器的大小(以字符为单位)。如果此值为0不使用lpWideCharStr缓冲区。 Return Value即返回值，返回写入到缓冲器的字符数。如果cchWideChar为0则返回缓冲器所需大小(以字符为单位)。 我们第一次调用此函数时应将cchWideChar设为0，并记录函数返回值，第二次调用时将cchWideChar设为此值。 WideCharToMultiByte与MultiByteToWideChar恰恰相反，但多两个参数，此函数可将UTF-16(宽字符)字符串映射到新字符串。 12345678910int WINAPI WideCharToMultiByte( UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar ); CodePage为指定执行转换的字符集。可选数值与MultiByteToWideChar相同，我们这里选择CP_ACP。 dwFlags设定转换类型。设为0即可。 lpWideCharStr指向一个要转换的字符串。 cchWideChar指定长度。对于宽字符，自行使用wcslen来获得。 lpMultiByteStr为指向接收缓冲器的指针。 cbMultiByte为lpMultiByteStr指示的缓冲器的大小(以字符为单位)。 lpDefaultChar为指向另一个接收缓冲器的指针，如果某个字符不能在指定的代码页中表示将使用此缓冲器。我们不需要，设为NULL即可。 lpUsedDefaultChar为一个指向BOOL变量的指针。如果使用了lpDefaultChar将被设为TRUE，否则为FALSE。我们也设为NULL即可。 Return Value即返回值，与MultiByteToWideChar相类比。 调用两次，步骤也与MultiByteToWideChar相似。 delete网上给的代码没有释放内存的语句，可能会造成内存泄露。 delete语句使用过指针都知道，释放一个指针指向的内存。 delete[]语句释放一个数组指针指向的内存。 如果想深入了解其中的原理，可以自行查阅。 小结这一节简单介绍了编码的知识和使用C++进行编码转换的代码。我们这个项目深入了解编码系统，所介绍的也不过是冰山一角。 现在大家已经可以自己写代码对网页进行简单分析了。下一节我打算介绍关于WinHTTP的内容和用途。","link":"/2019-05/28-spiking2/"},{"title":"技巧 - 在OJ上出交互题","text":"有关在OJ上出交互题的一些技巧 本博客所指的OJ仅指SYZOJ，即搭建LOJ使用的在线评测系统。 SYZOJ源码链接(Github仓库): https://github.com/syzoj/syzoj 前言在校内使用SYZOJ搭建内网OJ已经有些时日了。其实之前就看到有交互题这一说，但一直没有去关注和了解。 今天正颓废时，突然想起了交互题，然后开始便研究。 本以为是testlib，现在才发现SYZOJ有自己特有的交互方式。 正题SYZOJ帮助中的原话如下： 交互器和选手程序同时运行，交互器的标准输入和标准输出连接了选手程序的标准输出和标准输入 —— 交互通过输入输出进行。交互器运行时，其目录下会有 input 文件，表示该测试点的输入文件。交互器运行结束后，需要将选手得分写入 score.txt 文件中，并将提供给用户的额外信息输出到标准错误输出（stderr）中。如果您希望实现 NOI 试题风格的交互（选手通过函数调用与交互器交互），请编写一些头文件作为「附加源文件」并封装标准输入输出的交互。 要学习出交互题，前提是要会出一道传统题。对于出传统题就需要知道的知识就不予讲解。 如何交互根据帮助，交互通过输入输出进行，那么意为选手程序使用std::cout输出给交互器程序，而交互器程序使用std::cin读取选手的输出，反过来也是如此。 LOJ中交互题系统测试题Guess Number可以自行了解一下。 输入文件根据帮助，目录下会有 input 文件，表示该测试点的输入文件，那么就需要用文件流操作，我选择使用std::ifstream来读取input文件。交互器从输入文件读取一个整数的实例： 1234567#include &lt;fstream&gt;int n;int main() { std::ifstream datin(\"input\"); datin &gt;&gt; n; return 0;} 选手得分将选手得分写入 score.txt 文件中 也是同理，使用std::ofstream打开score.txt文件，写入一个数即可。 可以根据查询次数等信息来确定得分，支持部分正确（0 &lt;= 得分 &lt;= 100）。 额外信息继续看帮助，将提供给用户的额外信息输出到标准错误输出（stderr）中。额外信息就是测试点的反馈信息，我们常在传统题WA时看到Files user_out and answer differ。给出一个交互器判定选手输出的实例（不完整）： 1234567#include &lt;iostream&gt;int n, ans;int main() { // main_code std::cerr &lt;&lt; \"Wrong answer! The correct answer is \" &lt;&lt; ans &lt;&lt; \" .\" &lt;&lt; std::endl; return 0;} 当WA时输出正确的答案以供选手参考，与Special Judge类似。 封装交互帮助最后一句，是可选的。我们可以封装标准输入输出的交互，我们对于C++而言，可以写一个头文件interactor.h。 我们模拟一个很简单的题来示范interactor.h，选手输出两个数（代表一个坐标）与交互器进行交互，交互器返回一个数表示与终点的曼哈顿距离。 代码如下（只是interactor.h）： 1234567#include &lt;iostream&gt;int query(int x, int y){ std::cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; std::endl &lt;&lt; std::flush; int res; std::cin &gt;&gt; res; return res;} 你可以把它当做附加源文件提供给选手，方便不太懂的选手交互。 数据判断在交互过程中，交互器需要面对选手提供的各种输出数据。这些数据可能不合法，为了节省代码，介绍一个assert函数，貌似testlib中有类似的函数。 123456789template &lt; typename T &gt;inline void assert(const T &amp;condition, const std::string &amp;message) { if(!condition) { std::cerr &lt;&lt; message &lt;&lt; std::endl; score &lt;&lt; -1 &lt;&lt; std::endl; exit(0); } return;} 此函数是模板函数，刚入门C++的人可能不太懂。对于这个函数来讲，模板就是为了适用所有类型。condition为一个表达式，message为提供的额外信息。 判断选手输出是否为整数可以用以下代码，如果不是，cin就会出错，然后执行if中的语句（选手的输出等同于交互器的输入）。 12int x, y;assert(std::cin &gt;&gt; x &gt;&gt; y, \"Invalid `x` or `y`!\"); 交互器判断选手输出的数的范围也是如此： 1assert(x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= n, \"`x` and `y` must in [1, n]!\"); data.yml写好标程、题面，造好数据之后，对于SYZOJ的交互题必须用data.yml来指明交互器。 交互题与传统题的data.yml差别较小，只是增加交互器名称即可。使用C++11编写名为interactor.cpp的交互器，要在其中增加以下内容： 123interactor: language: cpp11 fileName: interactor.cpp 然后数据文件的ZIP中需要包含interactor.cpp文件。 后续总体来说比较简单。交互题一般能增大难度、限制选手的算法，也是强制在线的一种实现方法。","link":"/2019-07/12-zai-oj-shang-chu-jiao-hu-ti/"},{"title":"闲聊 - 毒瘤码风推荐","text":"用了这个码风，再也不怕代码出BUG了( 前言相信码风对于我们来说太熟悉了，以至于平常都忘记了它的存在 简介码风全称代码风格… 我就不啰嗦了，估计也都知道是啥，想看详细介绍可以右转代码风格-百度百科或Programming style-Wikipedia 正文那么就直接推荐自己的码风了 (从来不多打空格的可以跳过这一部分) 1234567891011// QuickReadinline int read() { int e= 0, f= 1; char ch= getchar(); while(ch &lt; '0' || ch &gt; '9') { if(ch == '-') f= -1; ch= getchar(); } while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') e= e * 10 + ch - '0', ch= getchar(); return e * f;} 这个空格写法确实毒瘤，估计像我这样的全世界应该有1%… 赋值符前不加空格，赋值符后加空格，运算符和逻辑符前后都加空格，手打不是很方便，习惯就好了. 大括号前不换行加空格，for循环中每个语句只在前加空格 (关于换行等事) 1234567891011121314// 负载平衡问题inline int absi(int i) { return i &gt; 0 ? i : -i;}int main() { cin &gt;&gt; n; for(int i= 1; i &lt;= n; i++) cin &gt;&gt; a[i], sum+= a[i]; sum/= n; for(int i= 1; i &lt;= n; i++) a[i]-= sum, s[i]= s[i - 1] + a[i]; sort(s + 1, s + n + 1), k= s[n / 2 + 1]; for(int i= 1; i &lt;= n; i++) ans+= absi(s[i] - k); cout &lt;&lt; ans &lt;&lt; endl; return 0;} 只遵守一个原则: 一行只存在一个分号, 能一行表示就不要多行表示 但也有例外，较长表达式不会压到一行，比较长的函数定义也不会压到一行 1234567891011// 匈牙利算法int dfs(int nown, int wptr) { for(int i= head[nown], to; i; i= eds[i].nexty) { to= eds[i].to; if(walkpast[to] != wptr) { walkpast[to]= wptr; if(!pp[to] || dfs(pp[to], wptr)) return pp[to]= nown, 1; } } return 0;} 大概就是这种码风，能省略就省略，但一行一条语句。 (判断语句和数组定义) 123456789101112// 主席树int main() { n= read(), m= read(); while(~scanf(\"%s\", o)) { tmpx= read(), tmpy= read(), tmpxx= read(), tmpyy= read(); if(o[0] == 'L') tmpc= read(), update(tmpx, tmpy, tmpc), update(tmpx, tmpyy + 1, -tmpc), update(tmpxx + 1, tmpy, -tmpc), update(tmpxx + 1, tmpyy + 1, tmpc); else printf(\"%d\\n\", query(tmpxx, tmpyy) - query(tmpx - 1, tmpyy) - query(tmpxx, tmpy - 1) + query(tmpx - 1, tmpy - 1)); } return 0;} 单行if不会换行，如果存在 else / else if 则换行 12345int db[]= { 0, 1, 1799998, 844059434, 446759866, 865662267, 29583524, 127902423, 614370802, 866384115, 771602680, 248905317, 78054944, 297165834, 271692212, 491940959, 329478404, 984412484, 35704862, 729995974, 257611164, 47520158, ...... 869867506, 732424548, 678809493, 143987677, 789130682, 973691054, 893883312, 311519914, 650459219, 821045358, 310559620, 775625624, 108543282, 54180205, 287135615, 875178490, 760920242, 512638949, 254323537, 977186041, 474130473, 455558106, 435916613, 787985317, 366892998, 42185197, 192850838, 421591125, 241779127, 969779315, 924599866, 723460313, 430999144}; 这个数组定义比较忙=迷，有的时候不会换行有的时候会 工具如果上面这些格式手动的话…估计考试一道题都做不完… 我目前使用VS Code，他的C++扩展自带格式化工具.clang-format 在 Visual Studio 和 Vim 中也可以用，并且配置文件是通用的 VS Code使用.clang-format: 安装C++扩展 -&gt; 选择工作文件夹 -&gt; 在文件夹下创建文件命名为.clang-format -&gt; 打开编辑 Visual Studio的使用.clang-format: 新建项目 -&gt; 创建.clang-format文件 -&gt; 编辑 .clang-format文件用法官方文档或者自行百度 常用设置: SpaceBeforeAssignmentOperator 为赋值符两边的空格 BraceWrapping 为各位置括号前后换行 ColumnLimit 为每行最大字符限制(和数组初始化换行有关) 放一下我的格式化文件配置:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990---Language: CppBasedOnStyle: LLVMAccessModifierOffset: 0AlignAfterOpenBracket: AlignAlignConsecutiveAssignments: falseAlignConsecutiveDeclarations: falseAlignEscapedNewlinesLeft: trueAlignOperands: trueAlignTrailingComments: trueAllowAllParametersOfDeclarationOnNextLine: trueAllowShortBlocksOnASingleLine: falseAllowShortCaseLabelsOnASingleLine: trueAllowShortFunctionsOnASingleLine: EmptyAllowShortIfStatementsOnASingleLine: trueAllowShortLoopsOnASingleLine: trueAlwaysBreakAfterDefinitionReturnType: NoneAlwaysBreakAfterReturnType: NoneAlwaysBreakBeforeMultilineStrings: trueAlwaysBreakTemplateDeclarations: trueBinPackArguments: falseBinPackParameters: falseBraceWrapping: AfterClass: false AfterControlStatement: false AfterEnum: false AfterFunction: false AfterNamespace: false AfterObjCDeclaration: false AfterStruct: false AfterUnion: false BeforeCatch: true BeforeElse: true IndentBraces: falseBreakBeforeBinaryOperators: NonAssignmentBreakBeforeBraces: CustomBreakBeforeTernaryOperators: falseBreakConstructorInitializersBeforeComma: falseColumnLimit: 250CommentPragmas: '^ IWYU pragma:'ConstructorInitializerAllOnOneLineOrOnePerLine: trueConstructorInitializerIndentWidth: 4ContinuationIndentWidth: 4Cpp11BracedListStyle: trueDerivePointerAlignment: falseDisableFormat: falseExperimentalAutoDetectBinPacking: falseForEachMacros: [ foreach, Q_FOREACH, BOOST_FOREACH ]IncludeCategories: - Regex: '^\"(llvm|llvm-c|clang|clang-c)/' Priority: 2 - Regex: '^(&lt;|\"(gtest|isl|json)/)' Priority: 3 - Regex: '.*' Priority: 1IndentCaseLabels: trueIndentWidth: 4IndentWrappedFunctionNames: falseKeepEmptyLinesAtTheStartOfBlocks: falseMacroBlockBegin: ''MacroBlockEnd: ''MaxEmptyLinesToKeep: 1NamespaceIndentation: InnerObjCBlockIndentWidth: 4ObjCSpaceAfterProperty: falseObjCSpaceBeforeProtocolList: truePenaltyBreakBeforeFirstCallParameter: 19PenaltyBreakComment: 300PenaltyBreakFirstLessLess: 120PenaltyBreakString: 1000PenaltyExcessCharacter: 1000000PenaltyReturnTypeOnItsOwnLine: 60PointerAlignment: RightReflowComments: trueSortIncludes: falseSpaceAfterCStyleCast: falseSpaceAfterTemplateKeyword: trueSpaceBeforeAssignmentOperators: falseSpaceBeforeParens: NeverSpaceInEmptyParentheses: falseSpacesBeforeTrailingComments: 2SpacesInAngles: trueSpacesInContainerLiterals: falseSpacesInCStyleCastParentheses: falseSpacesInParentheses: falseSpacesInSquareBrackets: falseStandard: Cpp11TabWidth: 4UseTab: Always... 最后用了这个码风，再也不怕代码出BUG了(","link":"/2019-02/15-du-liu-ma-feng-tui-jian/"},{"title":"重新开始","text":"关于重新搭建之前的主题用了半年多了，打算换个主题提高RP？ 然后又是先试了一个主题，发现太简洁没几个功能然后换成了现在这个。 总体来说还不错，不知道博客还能用几天。唉~ 关于现在搭建的方法,使用Github + Hexo + Nexmoe. 下面都是从第一篇博客复制过来的，有细微修改。 测试一下HelloWorld 12345#include &lt;iostream&gt;int main() { std::cout &lt;&lt; \"Hello, world!\" &lt;&lt; std:endl; return 0;} 测试一下LaTeX \\LARGE{S_k=\\sum_{i=1}^{k}a_i} 测试一下内嵌JS Ciyang's Blog 关于作者作者:Ciyang 现于 SD-SLYZ 上高中,是一名现役OIer,爱搞一些黑科技,写点高（la）端（ji）题解,出点毒（jian）瘤（dan）题,其实还仍是个中二少年…… 顺便说一句，头像还是很沙雕，所以凑活着看，以后再改。 然后最近颓的挺多，但是都没什么意义，希望有大佬跟给我推荐一些颓的东西。 联系方式:123QQ: 896681584Github: Xciyang网站通用昵称: Ciyang 关于博客这个博客不一定只发题解,多数应该还是一些黑科技,学习总结和经历之类的东西吧. 利益相关欢迎收藏~互加友链在那个友链页面评论吧！","link":"/2019-08/15-chong-xin-kai-shi/"},{"title":"开始","text":"关于搭建从下午搭建到现在,基本上算是搭建完了,文章从零开始,以后一点一点填吧. 其实博客在半月前就已经开始搭建了,只不过选择了一个没有什么配置手册的主题,然后扩展还比较少…最后不得不弃坑。 之前其实是从gitee上搭建的,现在听了周围dalao的建议,随波逐流来到了github 关于现在搭建的方法,使用Github + Hexo + Matery. 测试一下HelloWorld 12345#include &lt;iostream&gt;int main() { std::cout &lt;&lt; \"Hello, world!\" &lt;&lt; std:endl; return 0;} 测试一下LaTeX \\LARGE{S_k=\\sum_{i=1}^{k}a_i} 测试一下内嵌JS Ciyang's Blog 关于作者作者:Ciyang 现于 SD-SLYZ 上高中,是一名现役OIer,爱搞一些黑科技,写点高（la）端（ji）题解,出点毒（jian）瘤（dan）题,其实还仍是个中二少年…… 之前自己发明过MidHeap（BST）, 块状字典树（边压Trie）, 后来才知道已经被发明过了,但还是一直热衷于自创毒瘤数据结构来一举成名,其实毫无卵用. 最近打算颓U3D,做一款SLG网络国战手游,想的很美好,然后并没有时间和精力,还是先熟练U3D的基本操作吧. 顺便说一句,头像及其沙雕,所以凑活着看,以后再改. 联系方式:123QQ: 896681584Github: Xciyang网站通用昵称: Ciyang 关于博客这个博客不一定只发题解,多数应该还是一些黑科技,学习总结和经历之类的东西吧. 想设成粉色背景,然后估计被怼的几率比较大,就换了个颜色. 博客还会不断优化 相册会陆续换成自己的 借此吐槽一下这个主题 关于里面的技能是什么???为什么需要自己填写,自己写百分比… 其他技能又是什么???为什么要把文章标签当作其他技能…我的技能是闲聊…好像有道理. 现在已经关闭了那个功能,以后再自己实现吧. 利益相关欢迎收藏! 欢迎加友链!","link":"/2019-02/12-kai-shi/"}],"tags":[{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"比赛","slug":"比赛","link":"/tags/%E6%AF%94%E8%B5%9B/"},{"name":"Cpp","slug":"Cpp","link":"/tags/Cpp/"},{"name":"状压DP","slug":"状压DP","link":"/tags/%E7%8A%B6%E5%8E%8BDP/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"随机化搜索","slug":"随机化搜索","link":"/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"记忆","slug":"记忆","link":"/tags/%E8%AE%B0%E5%BF%86/"},{"name":"闲聊","slug":"闲聊","link":"/tags/%E9%97%B2%E8%81%8A/"},{"name":"语录","slug":"语录","link":"/tags/%E8%AF%AD%E5%BD%95/"},{"name":"GCD","slug":"GCD","link":"/tags/GCD/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"背包","slug":"背包","link":"/tags/%E8%83%8C%E5%8C%85/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"左偏树","slug":"左偏树","link":"/tags/%E5%B7%A6%E5%81%8F%E6%A0%91/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"离散化","slug":"离散化","link":"/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","link":"/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"name":"整除分块","slug":"整除分块","link":"/tags/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"主席树","slug":"主席树","link":"/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"分块","slug":"分块","link":"/tags/%E5%88%86%E5%9D%97/"},{"name":"字典树","slug":"字典树","link":"/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"边压Trie","slug":"边压Trie","link":"/tags/%E8%BE%B9%E5%8E%8BTrie/"},{"name":"块状链表","slug":"块状链表","link":"/tags/%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"ST表","slug":"ST表","link":"/tags/ST%E8%A1%A8/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"莫队","slug":"莫队","link":"/tags/%E8%8E%AB%E9%98%9F/"},{"name":"技巧","slug":"技巧","link":"/tags/%E6%8A%80%E5%B7%A7/"},{"name":"颓废","slug":"颓废","link":"/tags/%E9%A2%93%E5%BA%9F/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"alpha-beta剪枝","slug":"alpha-beta剪枝","link":"/tags/alpha-beta%E5%89%AA%E6%9E%9D/"},{"name":"记忆化搜索","slug":"记忆化搜索","link":"/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"项目","slug":"项目","link":"/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"码风","slug":"码风","link":"/tags/%E7%A0%81%E9%A3%8E/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"记忆","slug":"记忆","link":"/categories/%E8%AE%B0%E5%BF%86/"},{"name":"闲聊","slug":"闲聊","link":"/categories/%E9%97%B2%E8%81%8A/"},{"name":"技巧","slug":"技巧","link":"/categories/%E6%8A%80%E5%B7%A7/"},{"name":"项目","slug":"项目","link":"/categories/%E9%A1%B9%E7%9B%AE/"}]}